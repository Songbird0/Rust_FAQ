<?xml version="1.0" encoding="ISO-8859-1"?>
<document>
	<!--XML cr�� avec la version 16.8 du KitOOoDVP le 24/10/2016 02:23:25-->
	<!--En-t�te d'article-->
	<entete>
		<rubrique>89</rubrique>
		<meta>
			<description>Cette FAQ est tr�s certainement destin�e � �tre modif�e. Si vous parvenez � d�busquer une erreur dans les Q/R propos�es, vous pouvez la reporter.</description>
			<keywords/>
		</meta>
		<titre>
			<page>FAQ du langage Rust</page>
			<article>Rust FAQ</article>
		</titre>
		<date>2016-08-23</date>
		<miseajour>2016-08-23</miseajour>
		<extratag/>
		<google-analytics/>
		<licauteur>Songbird_</licauteur>
		<lictype>10</lictype>
		<licannee>2016</licannee>
		<serveur>identifiant-http</serveur>
		<chemin>tutoriels/XXX/YYY</chemin>
		<urlhttp>http://NomDomaine.developpez.com/tutoriels/XXX/YYY/</urlhttp>
		<pdf>
			<sautDePageAvantSection>0</sautDePageAvantSection>
			<notesBasPage>FinDocument</notesBasPage>
		</pdf>
		<microsofttraduction/>
	</entete>
	<lecteur>
		<!--Niveau de l'article-->
		<niveau type="1"/>
	</lecteur>
	<!--Descriptions des auteurs-->
	<authorDescriptions>
		<authorDescription name="Songbird_" role="auteur">
			<fullname>Songbird_</fullname>
			<url>http://www.developpez.net/forums/u897329/songbird_/</url>
			<blog>http://www.developpez.net/forums/blogs/897329-songbird_/</blog>
			<google-plus>https://plus.google.com/u/0/107675631188664643635</google-plus>
		</authorDescription>
	</authorDescriptions>
	<!--R�sum� tr�s bref de l'article affich� dans le cadre bleu en t�te de page-->
	<synopsis>
		<paragraph>Cette FAQ est tr�s certainement destin�e � �tre modif�e. Si vous parvenez � d�busquer une erreur dans les Q/R propos�es, reportez-la au responsable de la rubrique ou � un mainteneur de la FAQ, s'il vous pla�t.</paragraph>
		<paragraph><b>Note&#160;</b>: Il se pourrait qu'il y ait quelques confusions dans les Q/R - un deuxi�me passage sera fait quand une grande majorit� des Q/R auront �t� �crites.</paragraph>
	</synopsis>
	<summary>
		<section id="I">
			<title>Introduction</title>
			<section id="I-A">
				<title>Informations g�n�rales</title>
				<section id="I-A-1">
					<title>Stade de r�daction</title>
					<paragraph>WIP (il n'existe aucune publication "propre" de cette FAQ pour le moment)</paragraph>
				</section>
				<section id="I-A-2">
					<title>Pr�sentation</title>
					<paragraph>Cette FAQ a �t� con�ue pour r�pondre, certes, aux questions les plus courantes, mais �galement pour paraphraser certaines explications fournies par la documentation officielle qui auraient pu �tre mal comprises.</paragraph>
					<paragraph>Elle n'a en revanche pas pour but de traduire, mais bien de r�expliquer les passages qui pourraient s'av�rer compliqu�s � comprendre de prime abord. Vous pourrez donc y trouver des explications compl�tes, mais aussi des liens vers la documentation officielle si, � l'inverse, vous venez de d�couvrir Rust et ne vous �tes pas encore rendu(e) vers cette derni�re.</paragraph>
				</section>
				<section id="I-A-3">
					<title>Affiliation</title>
					<paragraph>Les ressources propos�es par ce d�p�t ne sont pas officielles ou affili�es � l'�quipe en charge du projet Rust et/ou la fondation Mozilla. Ce document peut toujours contenir des erreurs et/ou confusions pouvant �tre invalid�s; Bien que cette FAQ soit r�dig�e avec le plus grand soin, r�f�rez-vous toujours � la documentation officielle si vous avez un doute quant � la v�racit� des propos entretenus par cette ressource.</paragraph>
				</section>
				<section id="I-A-4">
					<title>Contribution</title>
					<paragraph>Vous souhaiteriez contribuer ? Super, nous vous remercions pour votre int�r�t � l'�gard de cette ressource. :)</paragraph>
					<paragraph>Il existe actuellement plusieurs moyens de contribuer � la maintenance (ou � l'enrichissement) de ce repo:</paragraph>
					<rich-imgtext type="info">
						<paragraph>Ce qui suit provient du <link href="https://github.com/Songbird0/Rust_FAQ#contribution" langue="Src" target="_blank" title="Ouvrir un nouvel onglet">repo github</link>. (d'o� les diff�rents moyens de contact)</paragraph>
					</rich-imgtext>
					<liste>
						<element>La fa�on la plus simple et directe de contribuer est la relecture orthographique du document. Pour ceci, r�cup�rez le <link href="https://github.com/Songbird0/Rust_FAQ/blob/master/rust_FAQ.xml">fichier xml</link>&#160;et ne vous pr�occupez que des paragraphres. (les m�ta-donn�es ne sont pas importantes pour cette t�che.)</element>
						<element useText="0">
							<paragraph>Il est �galement possible pour vous de corriger le document xml en utilisant les outils propos�s par&#160;<link href="https://github.com/Songbird0/Rust_FAQ/blob/master/developpez.com">developpez.com</link>, vous �vitant ainsi de modifier directement le document si sa lecture vous incommode; Si cette m�thode vous int�resse, n'h�sitez pas � me contacter&#160;<link href="https://twitter.com/_Spyglass_">ici</link>&#160;ou&#160;<link href="http://www.developpez.net/forums/u897329/songbird_/">ici</link>.</paragraph>
							<liste>
								<element>Aucun de ces liens ne vous convient pour me contacter ? Envoyez moi un mail � cet adresse: chaacygg[at]gmail[dot]com.</element>
							</liste>
						</element>
						<element useText="0">
							<paragraph>Enfin, il vous est possible d'enrichir ce document en proposant de nouvelles Questions/R�ponses ou tout simplement en cr�ant de nouvelles sections accueillant d'autres types de ressources. Contrairement � la relecture et l'�dition mineure, il serait plus sage d'opter pour utiliser le kit d'exportation que propose&#160;<link href="https://github.com/Songbird0/Rust_FAQ/blob/master/developpez.com">developpez.com</link>&#160;pour vous �vitez des t�ches d'�ditions fastidieuses.</paragraph>
							<liste>
								<element>Cette solution ne vous convient pas ? Aucun probl�me, une version markdown de la FAQ va bient�t �tre publi�e !</element>
							</liste>
						</element>
					</liste>
				</section>
				<section id="I-A-5">
					<title>Licence et condition d'utilisation</title>
					<rich-imgtext type="info">
						<paragraph>Ce qui suit provient du <link href="https://github.com/Songbird0/Rust_FAQ#licence-et-condition-dutilisation" langue="Src" target="_blank" title="Ouvrir un nouvel onglet">repo github</link>. (d'o� les diff�rents moyens de contact)</paragraph>
					</rich-imgtext>
					<paragraph>Des questions concernant l'utilisation de cette ressource ? Je vous invite � consulter le fichier LICENCE.md pour plus d'informations.</paragraph>
					<paragraph>Les informations contenues dans le fichier ne vous suffisent pas ? Contactez-moi:</paragraph>
					<liste>
						<element>
							<link href="https://twitter.com/_Spyglass_">Twitter</link>
						</element>
						<element>
							<link href="http://www.developpez.net/forums/u897329/songbird_/">Profil developpez</link>
						</element>
					</liste>
				</section>
			</section>
		</section>
		<section id="II">
			<title>Langage</title>
			<section id="II-A">
				<title>Questions g�n�rales</title>
				<section id="II-A-1">
					<title>Comment d�clarer une variable&#160;?</title>
					<paragraph>La d�claration d'une variable en Rust se fait par le biais du mot-cl� <inline langage="rust">let</inline>, permettant ainsi de diff�rencier une assignation d'une expression.</paragraph>
					<paragraph>Vous pouvez bien entendu d�clarer et initialiser plusieurs variables en m�me temps de cette mani�re&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1" titre="Assignation multiple">fn main() 
{
    let (foo, bar, baz) = (117, 42, "Hello world!");
}</code>
					<paragraph>Ou effectuer une d�claration multiligne&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="D�claration multiligne">fn main()
{
    let foo = 117;
    let bar = 42;
    let baz = "Hello world!";
}</code>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-3" title="Rust poss�de-t-il un typage dynamique&#160;?">Rust poss�de-t-il un typage dynamique&#160;?</link></paragraph>
				</section>
				<section id="II-A-2">
					<title>Comment assigner un objet par r�f�rence&#160;?</title>
					<paragraph>Il existe deux fa�ons de faire&#160;:</paragraph>
					<liste type="1">
						<element>Pr�ciser par le biais du caract�re &amp;. (C-style)</element>
						<element>En utilisant le mot-cl� <inline langage="rust">ref</inline> comme ceci&#160;:</element>
					</liste>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn main() 
{
    let foo = 117i32;
    let ref bar = foo;
    let baz = &amp;foo; //idem
}</code>
				</section>
				<section id="II-A-3">
					<title>Rust poss�de-t-il un typage dynamique&#160;?</title>
					<paragraph>Non.</paragraph>
					<paragraph>Bien qu'il en donne l'air gr�ce � une syntaxe tr�s a�r�e, Rust dispose d'un typage statique mais �&#160;optionnel&#160;� pour le d�veloppeur si il d�sire faire abstraction des types, mais il perdra, en toute logique, l'avantage de choisir la quantit� de m�moire que sa ressource consommera.</paragraph>
					<paragraph>Vous ne pouvez, par exemple, pas faire ceci&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1">fn main() 
{
    let mut foo = 1;
    foo = " Hello world !";
}</code>
					<paragraph>Le type ayant �t� fix� par la premi�re donn�e, il n'est plus possible de changer en cours de route.</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-4" title="Comment typer ses donn�es/variables&#160;?">Comment typer ses donn�es/variables</link>&#160;?</paragraph>
				</section>
				<section id="II-A-4">
					<title>Comment typer ses donn�es/variables&#160;?</title>
					<paragraph>Pour les types primitifs, il existe deux mani�res de typer une variable&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1" titre="Les diff�rentes mani�res de typer">fn main() 
{
    let foo : i32 = 117;
}</code>
					<paragraph>Ou&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Les diff�rentes mani�res de typer">fn main() 
{
    let bar = 117i32;
}</code>
				</section>
				<section id="II-A-5">
					<title>Quelle est la diff�rence entre &amp;str et String&#160;?</title>
					<paragraph>Du point de vue des packages, <inline langage="rust">String</inline> se trouve dans le package <inline langage="rust">std::string</inline> et <inline langage="rust">&amp;str</inline> dans le package <inline langage="rust">std</inline>.</paragraph>
					<paragraph>Du point de vue des types, <inline langage="rust">String</inline> est un wrapper de <inline langage="rust">&amp;str</inline> et ce dernier est tout simplement l'alias repr�sentant le type primitif des cha�nes de caract�res.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn main() 
{
    let foo : &amp;str = "Hello world!"; //�a fonctionne
    let bar : String = foo; //erreur
    let baz : String = String::from(foo); //Ok !
}</code>
				</section>
				<section id="II-A-6">
					<title>Comment cr�er une cha�ne de caract�res&#160;?</title>
					<paragraph>La question pourrait para�tre �vidente dans d'autres langages, toutefois, apr�s avoir �crit quelque chose de ce style&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1" titre="Cr�er une cha�ne de caract�res">fn main() 
{
    let foo : String = "Hello world!";
}</code>
					<paragraph>Le compilateur vous a renvoy� cette erreur&#160;:</paragraph>
					<code dissimulable="0" langage="texinfo" titre="Message d'erreur">  |>
4 |>    let foo : String = "Hello world!";
  |>                       ^^^^^^^^^^^^^^ expected struct `std::string::String`, found &amp;-ptr</code>
					<paragraph>Il se trouve que la structure <inline langage="rust">String</inline> est un wrapper.</paragraph>
					<paragraph>Vous vous retrouvez donc � typer votre variable pour accueillir une instance de la structure <i>String</i> alors que vous cr�ez une cha�ne de caract�res primitive.</paragraph>
					<paragraph>Pour rem�dier au probl�me (si vous souhaitez malgr� tout utiliser le wrapper), vous pouvez convertir une cha�ne de caract�res de type <inline langage="rust">&amp;str</inline> gr�ce � la fonction <inline langage="rust">String::from()</inline>&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn main()
{
    let foo : String = String::from("Hello world!");
    //ou
    let foo : &amp;str = "Hello world!";
}</code>
				</section>
				<section id="II-A-7">
					<title>Quelle version de Rust est recommand�e&#160;?</title>
					<paragraph>Actuellement<noteBasPage><i><b>25 septembre 2016</b></i></noteBasPage>, la version stable la plus r�cente est la <b>1.12.0</b>.</paragraph>
					<paragraph>Mais vous pouvez toutefois utiliser une version un peu plus vieille.</paragraph>
					<paragraph>Pour cette Q/R, la version de Rust sur mon poste �tait  la <b>1.9.0</b>.</paragraph>
					<rich-imgtext type="info">
						<paragraph>Gardez tout de m�me � l'esprit que si vous n'avez pas encore entrepris des projets qui vous tiennent � c�ur avec Rust, il va de soit de se tourner vers la derni�re version en date pour b�n�ficier des derniers ajouts/corrections.</paragraph>
					</rich-imgtext>
					<rich-imgtext type="warning">
						<paragraph>La 1.9.0 comporte un bogue concernant les tests unitaires.</paragraph>
					</rich-imgtext>
					<paragraph>Voir aussi&#160;: <link href="https://www.rust-lang.org/en-US/" langue="En" target="_blank" title="Ouvrir un nouvel onglet">Page officielle du langage Rust</link></paragraph>
				</section>
				<section id="II-A-8">
					<title>Rust est-il orient� objet&#160;?</title>
					<paragraph>Rust h�rite des structures du <i>C</i>, elles n'incluent donc pas l'encapsulation des donn�es comme nous pourrions l'imaginer avec une classe.</paragraph>
					<paragraph>Il dispose d'un aspect de la POO, de prime abord, assez primitif&#160;; Rust permet toutefois de b�n�ficier du polymorphisme gr�ce aux �&#160;traits&#160;� qui pourraient �tre compar�es aux interfaces Java/C#.</paragraph>
					<paragraph>Cependant, le langage ne supporte pas l'h�ritage multiple (ni l'h�ritage simple) entre les structures&#160;: comme il serait possible de le faire avec des classes.</paragraph>
					<rich-imgtext type="info">
						<paragraph>Il est tout � fait possible de faire h�riter plusieurs traits entre-eux, en revanche.</paragraph>
					</rich-imgtext>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-9" title="Qu'est-ce qu'un �&#160;trait&#160;�&#160;?">Qu'est-ce qu'un �&#160;trait&#160;�&#160;?</link></paragraph>
				</section>
				<section id="II-A-9">
					<title>Qu'est-ce qu'un �&#160;trait&#160;�&#160;?</title>
					<paragraph>Un trait pourrait �tre compar� aux interfaces que l'on peut retrouver dans la plupart des langages orient�s objet. (e.g. Java, C#)</paragraph>
					<paragraph>Les traits vous permettent de d�clarer des fonctions abstraites/virtuelles pour ensuite les impl�menter au sein d'une structure gr�ce au mot-cl� <inline langage="rust">impl</inline> comme ceci&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">trait Greeter
{
    fn greetings(&amp;self);
}

struct Person;

impl Greeter for Person
{
    fn greetings(&amp;self)
    {
        println!("Hello, my friends!");
    }
}

fn main()
{
    let person = Person;
    person.greetings();
}</code>
				</section>
				<section id="II-A-10">
					<title>Rust supporte-t-il la surchage des fonctions&#160;?</title>
					<paragraph>Rust ne supporte pas la surcharge des fonctions.</paragraph>
					<paragraph>Le langage repose sur le �&#160;Builder Pattern&#160;� qui consiste � concevoir des �&#160;fabriques/factories&#160;� charg�es de g�n�rer l'objet d�sir�.</paragraph>
					<paragraph>Vous pouvez retrouver quelques explications � propos de ce design pattern <link href="https://doc.rust-lang.org/book/method-syntax.html#builder-pattern" langue="En" target="_blank">ici</link> ou encore <link href="https://fr.wikipedia.org/wiki/Monteur_(patron_de_conception)#Exemple" langue="Fr" target="_blank" title="Ouvrir un nouvel onglet">ici</link>.</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-11" title="Comment d�clarer des param�tres optionnels&#160;?">Comment d�clarer des param�tres optionnels</link>&#160;?</paragraph>
				</section>
				<section id="II-A-11">
					<title>Comment d�clarer des param�tres optionnels&#160;?</title>
					<paragraph>Il n'est pas possible de d�clarer des param�tres optionnels avec Rust dans sa version actuelle.</paragraph>
					<paragraph>Toutefois, il est toujours possible d'user de macros pour capturer diff�rentes expressions et ainsi adapter votre code en fonction de la situation.</paragraph>
					<paragraph>Le langage repose sur le �&#160;Builder Pattern&#160;� qui consiste � concevoir des �&#160;fabriques/factories&#160;� charg�es de g�n�rer l'objet d�sir�.</paragraph>
					<paragraph>Vous pouvez retrouver quelques explications � propos de ce design pattern <link href="https://doc.rust-lang.org/book/method-syntax.html#builder-pattern" langue="En" target="_blank">ici</link> ou encore <link href="https://fr.wikipedia.org/wiki/Monteur_(patron_de_conception)" langue="Fr" target="_blank" title="Ouvrir un nouvel onglet">ici</link>.</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-33" title="Comment utiliser une macro&#160;?">Comment utiliser une macro&#160;?</link></paragraph>
				</section>
				<section id="II-A-12">
					<title>Comment cr�er un tableau&#160;?</title>
					<paragraph>Un tableau dans sa forme la plus primitive se d�clare comme ceci&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1" titre="D�claration d'un tableau d'entiers">let foo : [i32; 10] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</code>
					<paragraph><b>Note&#160;</b>: la taille du tableau doit �tre explicite, sous peine de recevoir une erreur de la part du compilateur.</paragraph>
				</section>
				<section id="II-A-13">
					<title>A quoi sert le mot-cl� super&#160;?</title>
					<paragraph>Contrairement � ce que l'on pourrait croire, le mot-cl� <inline langage="rust">super</inline> ne repr�sente pas une r�f�rence vers l'instance courante d'une classe m�re, mais repr�sente seulement le �&#160;scope&#160;� sup�rieur. (dans un module)</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� super">mod mon_module
{
    pub fn ma_fonction()
    {
        println!("Scope sup�rieur");
    }
    pub mod fils
    {
        pub fn fonction_enfant()
        {
            super::ma_fonction();
        }
    }
    pub mod fille
    {
        pub fn fonction_enfant()
        {
            super::ma_fonction();
        }
    }
}

fn main()
{
    mon_module::fils::fonction_enfant();
    mon_module::fille::fonction_enfant();
}</code>
				</section>
				<section id="II-A-14">
					<title>A quoi sert le mot-cl� self&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">self</inline> renvoie � une copie (ou la r�f�rence(<inline langage="rust">&amp;self</inline>)) de l'instance courante.</paragraph>
					<paragraph>Il est souvent rencontr�&#160;: </paragraph>
					<liste>
						<element>lorsqu'une fonction virtuelle/abstraite est impl�ment�e au sein d'une structure,</element>
						<element>lorsque le d�veloppeur doit utiliser une fonction dans le module courant, </element>
						<element>&#8230;</element>
					</liste>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� self">trait My_Trait
{
    fn my_func(&amp;self);
}

mod My_Mod
{
    fn foo()
    {
        self::bar();
    }
    
    fn bar()
    {
    
    }
}</code>
				</section>
				<section id="II-A-15">
					<title>A quoi sert le mot-cl� use&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">use</inline> permet de raccourcir le �&#160;chemin&#160;� des d�pendences du programme, vous �vitant ainsi d'expliciter les d�pendences de chacune de vos ressources.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� use">extern crate mon_package&#160;;

use mon_package::mon_module::ma_fonction&#160;;

fn main()
{
    ma_fonction()&#160;;
}</code>
					<paragraph>Autrement dit, toute structure compos�e de diff�rentes ressources peut �tre exploit�e par le mot-cl� <inline langage="rust">use</inline>.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� use sur une �num�ration">enum MonEnum
{
    Arg1,
    Arg2,
}

fn main()
{
    use MonEnum::{Arg1};
    let instance = Arg1; //plus la peine d'expliciter d'o� provient l'instance Arg1 comme ceci:
    // let instance = MonEnum::Arg1;
}</code>
				</section>
				<section id="II-A-16">
					<title>A quoi sert le mot-cl� pub&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">pub</inline> peut �tre utilis� dans <i>trois</i> contextes diff�rents&#160;:</paragraph>
					<liste type="1">
						<element>Au sein [et sur] des modules&#160;;</element>
						<element>Au sein [et sur] des traits&#160;;</element>
						<element>Au sein [et sur] des structures.</element>
					</liste>
					<paragraph>Dans un premier temps, qu'il soit utilis� sur des <inline langage="rust">mod</inline>ules, <inline langage="rust">trait</inline>s, ou <inline langage="rust">struct</inline>ures, il aura toujours la m�me fonction&#160;: rendre publique l'objet concern�.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="1" langage="text" showLines="1" startLine="1" titre="Structure du projet">&#9500;&#9472;&#9472; Cargo.lock
&#9500;&#9472;&#9472; Cargo.toml
&#9500;&#9472;&#9472; src
&#9474;&#160;&#160; &#9500;&#9472;&#9472; lib.rs
&#9474;&#160;&#160; &#9492;&#9472;&#9472; main.rs
&#9492;&#9472;&#9472; target
    &#9492;&#9472;&#9472; debug
        &#9500;&#9472;&#9472; build
        &#9500;&#9472;&#9472; deps
        &#9500;&#9472;&#9472; examples
        &#9500;&#9472;&#9472; libmon_projet.rlib
        &#9500;&#9472;&#9472; mon_projet
        &#9492;&#9472;&#9472; native</code>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Dans le fichier lib.rs">pub mod ma_lib //la module repr�sentant ma biblioth�que
{
    pub mod mon_module //un module lambda
    {
        pub fn ma_fonction() //ma fonction
        {
            println!("Hi there !");
        }
    }
}</code>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Dans le fichier main.rs">extern crate mon_projet;
use mon_projet::ma_lib::mon_module::ma_fonction;
fn main() 
{
    ma_fonction();
}</code>
					<paragraph>Renvoie&#160;:</paragraph>
					<code dissimulable="1" langage="text" showLines="1" startLine="1" titre="Console">Hi there !</code>
					<rich-imgtext type="idea">
						<paragraph>Mais d'o� provient �&#160;mon_projet&#160;�&#160;?</paragraph>
					</rich-imgtext>
					<paragraph>�&#160;mon_projet&#160;� est le nom port� par votre projet dans le manifest Cargo.toml.</paragraph>
					<paragraph>Pour cet exemple, voici le manifest r�dig�&#160;:</paragraph>
					<code dissimulable="1" langage="toml" showLines="1" startLine="1" titre="Dans le manifest">[package]
name = "mon_projet"
version = "0.1.0"
authors = ["Songbird0 &lt;chaacygg@gmail.com>"]

[dependencies]</code>
					<paragraph>
						<b>Quid lorsque pub est utilis� au sein de ces structures&#160;?</b>
					</paragraph>
					<paragraph>Lorsque le mot-cl� <inline langage="rust">pub</inline> est utilis� au sein d'un <inline langage="rust">trait</inline> ou d'une <inline langage="rust">struct</inline>ure sur une fonction, cela rend cette derni�re ind�pendante de l'instance d'un objet. (mais peut toujours �tre appel�e par l'une d'elles)</paragraph>
					<paragraph>Autrement dit, la fonction est statique.</paragraph>
					<code langage="rust" showLines="1" startLine="1">struct A;

impl A
{
    pub fn foo()
    {
        println!("Je suis statique !");
    }
    
    pub fn new() -> A
    {
        return A;
    }
    
    fn bar(&amp;self)
    {
        println!("Fonction non-statique");
    }
}

fn main()
{
    let instance : A = A::new();
    A::foo();
    instance.bar();
    //instance::bar() -> erreur
}</code>
				</section>
				<section id="II-A-17">
					<title>A quoi servent les mot-cl�s extern crate&#160;?</title>
					<paragraph>Les mot-cl�s <inline langage="rust">extern crate</inline> permettent d'importer un paquet entier de modules dans le fichier courant.</paragraph>
					<paragraph>Le principe est simple, il vous suffit seulement de cr�er en premier lieu un projet en mode �&#160;biblioth�que&#160;� pour r�unir tous les modules que vous cr�erez, de cr�er un fichier qui accueillera le point d'entr�e de votre programme, puis d'importer votre paquet.</paragraph>
					<paragraph>Bien entendu, si vous souhaitez importer un paquet qui n'est pas de vous, il vous faudra l'inscrire dans votre manifest.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<paragraph>Pour voir un exemple de cr�ation de paquet, vous pouvez vous rendre � la Q/R&#160;:  �&#160;<link href="#LII-A-16" title="A quoi sert le mot-cl� pub&#160;?">A quoi sert le mot-cl� pub&#160;?</link>&#160;�</paragraph>
					<paragraph>
						<link href="#LII-C-6" title="Comment installer de nouvelles biblioth�ques&#160;?">Comment installer de nouvelles biblioth�ques&#160;?</link>
					</paragraph>
				</section>
				<section id="II-A-18">
					<title>A quoi sert le mot-cl� mod&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">mod</inline> vous permet de cr�er un module.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<paragraph>
						<link href="#LII-A-19" title="A quoi sert un module&#160;?">A quoi sert un module&#160;?</link>
					</paragraph>
				</section>
				<section id="II-A-19">
					<title>A quoi sert un module&#160;?</title>
					<paragraph>Il vous permet de r�unir plusieurs objets (<inline langage="rust">struct</inline>ures, <inline langage="rust">trait</inline>s, fonctions, d'autres <inline langage="rust">mod</inline>ules&#8230;) dans un m�me fichier puis de les r�utiliser � plusieurs endroits dans votre programme.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>
							<link href="#LII-A-16" title="A quoi sert le mot-cl� pub&#160;?">A quoi sert le mot-cl� pub&#160;?</link>
						</element>
						<element>
							<link href="#LII-A-17" title="A quoi servent les mot-cl�s extern crate&#160;?">A quoi servent les mot-cl�s extern crate&#160;?</link>
						</element>
					</liste>
				</section>
				<section id="II-A-20">
					<title>Comment cr�er un module&#160;?</title>
					<paragraph>Voici comment cr�er un <inline langage="rust">mod</inline>ule&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� mod">mod A
{
    fn votre_fonction(){}
    fn une_autre_fonction(){}
    mod B
    {
        struct C{}
        trait D{}
    }
}</code>
				</section>
				<section id="II-A-21">
					<title>A quoi sert le mot-cl� type&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">type</inline> permet de cr�er des <i>alias</i> et ainsi r�duire la taille des types personnalis�s (ou primitifs).</paragraph>
					<paragraph>Voici un exemple&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� type">struct VeryLongTypeName;

impl VeryLongTypeName
{
    pub fn new() -> VeryLongTypeName
    {
        println!("In new function");
        return VeryLongTypeName;
    }
}

type ShortName = VeryLongTypeName;

fn main()
{
    let foo = ShortName::new();
}</code>
					<rich-imgtext type="warning">
						<paragraph>Les alias ne fonctionnent pas pour les �&#160;traits&#160;�, si vous essayez de lier un alias � l'identifiant d'un trait, le compilateur vous renverra une erreur. (tr�s explicite)</paragraph>
					</rich-imgtext>
					<paragraph>Liens&#160;:</paragraph>
					<paragraph>Pour ex�cuter l'exemple de la Q/R, vous pouvez vous rendre <link href="https://is.gd/hPONv0" target="_blank" title="Rust Playground">ici</link>.</paragraph>
					<paragraph>Retrouvez des explications <link href="http://stackoverflow.com/questions/29447920/what-is-the-rust-type-keyword" target="_blank" title="Post StackOverflow">ici</link>.</paragraph>
					<paragraph><link href="http://rustbyexample.com/cast/alias.html" target="_blank" title="Rust by Example">Explications de la documentation officielle</link>.</paragraph>
				</section>
				<section id="II-A-22">
					<title>A quoi sert le mot-cl� loop&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">loop</inline> est un sucre syntaxique qui permet de remplacer le fameux&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">while(true)
{

}

// ou

for(;;)
{

}</code>
					<paragraph>Pr�f�rez donc cette syntaxe&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1">loop
{

}</code>
					<paragraph>Liens&#160;:</paragraph>
					<paragraph><link href="https://doc.rust-lang.org/book/loops.html#loop" target="_blank" title="Ancre vers le mot-cl� loop">Documentation officielle</link>.</paragraph>
				</section>
				<section id="II-A-23">
					<title>A quoi sert le mot-cl� where&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">where</inline> permet de filtrer les objets pass�s en param�tres dans une fonction g�n�riques, par exemple&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� where">trait Soldier{}
trait Citizen{}
struct A;
struct B;
impl Soldier for A{}
fn foo&lt;T>(test: T) -> T where T: Soldier
{
    return test;
}
fn main()
{
    let soldier : A = A;
    let citizen : B = B;
    foo(soldier);
    foo(citizen); //error: the trait bound `B: Soldier` is not satisfied
}</code>
				</section>
				<section id="II-A-24">
					<title>A quoi sert le mot-cl� unsafe&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">unsafe</inline> permet, comme son nom l'indique, de casser certaines r�gles natives de Rust pour effectuer des op�rations �&#160;� risque&#160;�.</paragraph>
					<paragraph><inline langage="rust">unsafe</inline> peut �tre utilis� dans quatre contextes diff�rents&#160;:</paragraph>
					<paragraph>La d�claration d'une fonction&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1">unsafe fn dangerous_function() {}</code>
					<paragraph>La cr�ation d'un nouveau scope&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1">fn main() &#8594; ()
{
    unsafe {/*dangerous scope*/}
}</code>
					<paragraph>La d�claration d'un trait&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1">unsafe trait Dangerous_trait{}</code>
					<paragraph>L'impl�mentation d'un trait&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1">unsafe impl A for B&#160;{}</code>
					<paragraph>En pratique, le mot-cl� <inline langage="rust">unsafe</inline> permet une manipulation de la m�moire plus approfondie, plus directe, mais aussi plus compliqu�e, puisque le langage n'applique pas certaines r�ges.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<paragraph>
						<link href="#LII-A-25" title="Quelles sont les r�gles non-appliqu�es dans ces contextes&#160;?">Quelles sont les r�gles non-appliqu�es dans ces contextes&#160;?</link>
					</paragraph>
					<paragraph>
						<link href="#LII-A-26" title="Quels comportements sont consid�r�s �&#160;non-s�rs&#160;� par Rust&#160;?">Quels comportements sont consid�r�s �&#160;non-s�rs&#160;� par Rust&#160;?</link>
					</paragraph>
				</section>
				<section id="II-A-25">
					<title>Quelles sont les r�gles non-appliqu�es dans ces contextes&#160;?</title>
					<paragraph>Trois r�gles, et seulement trois, sont bris�es dans les blocs (et fonctions) <inline langage="rust">unsafe</inline>:</paragraph>
					<liste type="1">
						<element>L'acc�s et la modification d'une variable globale (statique) muable sont autoris�s&#160;;</element>
						<element>Il est possible de d�r�f�rencer un pointeur (non-nul, donc)&#160;;</element>
						<element>Il est possible de faire � une fonction non-s�re.</element>
					</liste>
				</section>
				<section id="II-A-26">
					<title>Quels comportements sont consid�r�s �&#160;non-s�rs&#160;� par Rust&#160;?</title>
					<paragraph>Pour en retrouver une liste exhaustive, rendez-vous � la <link href="https://doc.rust-lang.org/book/unsafe.html#what-does-safe-mean" langue="En" target="_blank" title="Ouvrir un nouvel onglet">section d�di�e</link>.</paragraph>
				</section>
				<section id="II-A-27">
					<title>A quoi sert le mot-cl� fn&#160;?</title>
					<paragraph>En rust, pour d�clarer une fonction, il faut utiliser le mot-cl� <inline langage="rust">fn&#160;</inline>:</paragraph>
					<code langage="rust" showLines="1" startLine="1">fn ma_fonction()
{

}</code>
				</section>
				<section id="II-A-28">
					<title>A quoi sert le mot-cl� match&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">match</inline> nous permet d'impl�menter le <i>pattern</i> <i>matching</i>.</paragraph>
					<paragraph>Ainsi, il est possible de comparer une entr�e � plusieurs tokens constants et agir en cons�quence. Le pattern matching est consid�r� comme un test <i>exhaustif</i>, car, quoi qu'il arrive, il fera en sorte de couvrir tous les cas de figure qu'on lui propose.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Impl�mentation du pattern matching">    let foo : i32 = 117;
    match foo
    {
        117 => println!("foo's value equals 117 !"),
        _ => println!("You know nothing, John."), //s'�fforcera de trouver une r�ponse
    }</code>
					<paragraph>Jusqu'ici, il semblerait que le mot-cl� <inline langage="rust">match</inline> ne soit pas capable de faire preuve de plus de souplesse qu'un <inline langage="java">switch</inline>, ce qui est bien entendu le contraire&#160;!</paragraph>
					<paragraph>Vous pouvez assigner le r�sultat de vos tests directement dans une variable sans avoir � l'�crire dans votre <inline langage="java">switch</inline>/<inline langage="rust">match</inline>.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Assignation automatique">fn main()
{
    let foo : i32 = 117;
    let mut bar : String;
    match foo
    {
        117 => println!("foo's value equals 117 !"),
        _ => println!("You know nothing, John."),
    }
    
    bar = match foo
    {
        117 => "It's ok !".to_string(),
        _ => "foo isn't equals to 117".to_string(),
    };
    
    println!("{}", &amp;bar);
}</code>
					<paragraph>Voir aussi&#160;: </paragraph>
					<paragraph>Vous pouvez ex�cuter l'exemple <link href="https://is.gd/otk1eC" target="_blank">ici</link>.</paragraph>
					<paragraph>Vous pouvez retrouver <link href="https://en.wikipedia.org/wiki/Pattern_matching" langue="En" target="_blank">une source</link> abordant le pattern matching. (avec plusieurs exemples)</paragraph>
					<paragraph><link href="https://doc.rust-lang.org/book/match.html" langue="En" target="_blank">Partie de la documentation officielle abordant l'impl�mentation du pattern matching</link>.</paragraph>
				</section>
				<section id="II-A-29">
					<title>A quoi sert le mot-cl� ref&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">ref</inline> est une alternative au caract�re sp�cial <inline langage="rust">&amp;</inline> pour expliciter le renvoie d'une r�f�rence d'un objet&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� ref">struct A&#160;;
fn main()
{
    let foo&#160;: A = A&#160;;
    let bar&#160;: &amp;A = &amp;foo&#160;; // ou let ref bar&#160;= foo&#160;;
}</code>
				</section>
				<section id="II-A-30">
					<title>A quoi sert le mot-cl� mut&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">mut</inline> permet de rendre l'une de vos variable muables lors de sa d�claration.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation du mot-cl� mut">let mut foo&#160;: i32 = 0&#160;;
let bar&#160;: i32 = 1&#160;;
foo = 1&#160;;
bar = 2&#160;; //erreur</code>
				</section>
				<section id="II-A-31">
					<title>Une erreur survient lorsque que je modifie le contenu de ma variable&#160;! Que faire&#160;?</title>
					<paragraph>Il se peut que vous ayez omis la particularit� de Rust&#160;: tout est immuable par d�faut.</paragraph>
					<paragraph>Pour permettre � une variable de modifier son contenu, il vous faudra utiliser le mot-cl� <inline langage="rust">mut</inline>.</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-30" title="A quoi sert le mot-cl� mut&#160;?">A quoi sert le mot-cl� mut&#160;?</link></paragraph>
				</section>
				<section id="II-A-32">
					<title>Qu'est-ce qu'une macro&#160;?</title>
					<paragraph>Une macro est ce que l'on peut appeler vulgairement&#160;: une fonction tr�s puissante.</paragraph>
					<paragraph>Gr�ce aux macros, nous pouvons capturer <i>plusieurs</i> groupes <i>d'expressions</i> et ainsi �crire les instructions d�sir�es selon <i>chaque</i> cas.</paragraph>
					<paragraph>En Rust, c'est ce qui se rapproche le plus de la <i>surcharge de m�thodes</i> en Java.</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-33" title="Comment utiliser une macro&#160;?">Comment utiliser une macro&#160;?</link></paragraph>
				</section>
				<section id="II-A-33">
					<title>Comment utiliser une macro&#160;?</title>
					<paragraph>Pour utiliser une macro, il faut d'abord la d�clarer en utilisant le mot-cl� <inline langage="rust">macro_rules!</inline>. </paragraph>
					<rich-imgtext type="warning">
						<paragraph><b>Attention</b>, il ne doit pas y avoir d'espace(s) entre<inline langage="rust">macro_rules</inline> et le point d'exclamation.</paragraph>
					</rich-imgtext>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="D�claration d'une macro">macro_rules! foo
{
    () => ();
}</code>
					<paragraph>Toutes les macros (y compris celle pr�sent�e ici) respestent une r�gle tr�s importante&#160;: elles doivent toutes capturer au moins une expression pour �tre valide et compil�es. (en l'occurrence, la regex <inline langage="rust">() => ()&#160;;</inline>)</paragraph>
					<paragraph>C'est donc cela, l'une des diff�rences majeures entre une fonction/proc�dure et une macro&#160;: cette derni�re est capable de capturer des expressions rationnelles, conserver en m�moire ce que d�sire le d�veloppeur, puis de les r�-utiliser dans le corps de l'une d'entre-elles.</paragraph>
					<paragraph>Ces �&#160;super&#160;� fonctions demandent donc quelques notions li�es aux expressions rationnelles pour vous permettre d'appr�cier pleinement ce puissant m�canisme.</paragraph>
					<paragraph>Voici un exemple tr�s basique de macro&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Exemple d'utilisation d'une macro">/// **Attention**:
/// 
///Cette macro n'utilise qu'un seul type de sp�cificateur, mais il en existe beaucoup d'autres.
macro_rules! foo
{
    ($your_name:expr, $your_last_name:expr, $carriage_return: expr) =>
    {
        if $carriage_return == true
        {
            println!("My name's {} {}.", $your_name, $your_last_name); 
        }
        else { print!("My name's {} {}.", $your_name, $your_last_name); }
    };
    
    ($your_name:expr, $your_last_name:expr) =>
    {
        foo!($your_name, $your_last_name, false);
    };
    
    ($your_name:expr) =>
    {
        foo!($your_name, "", false);
    };
}

fn main() -> ()
{
    foo!("Song", "Bird", true);
    foo!("Song", "Bird"); //pas de retour � la ligne
    foo!("Song"); //l� non plus
}</code>
					<paragraph>Vous aurez certainement remarqu� que les param�tres pass�s sont assez sp�ciaux&#160;; Au lieu d'avoir le nom de leur type apr�s les deux points (�&#160;:&#160;�), il est �crit <inline langage="rust">expr</inline>.</paragraph>
					<paragraph>C'est ce que l'on appelle un �&#160;sp�cificateur&#160;�&#160;.</paragraph>
					<paragraph>Liens&#160;:</paragraph>
					<paragraph>
						<link href="https://is.gd/nHfcEQ" target="_blank" title="Exemple d'utilisation d'une macro">Visionner le r�sultat de cet exemple.</link>
					</paragraph>
					<paragraph>
						<link href="#LII-A-34" title="Que sont les sp�cificateurs&#160;?">Que sont les sp�cificateurs&#160;?</link>
					</paragraph>
				</section>
				<section id="II-A-34">
					<title>Que sont les sp�cificateurs&#160;?</title>
				</section>
				<section id="II-A-35">
					<title>A quoi sert le mot-cl�  usize&#160;?</title>
					<paragraph>Le mot-cl� <inline langage="rust">usize</inline> permet de laisser le compilateur choisir la taille en m�moire d'un entier <i>non-sign�</i>. (selon l'architecture de la machine sur laquelle le programme sera ex�cut�)</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-36" title="A quoi sert le mot-cl� isize&#160;? ">A quoi sert le mot-cl� isize&#160;?</link></paragraph>
				</section>
				<section id="II-A-36">
					<title>A quoi sert le mot-cl� isize&#160;? </title>
					<paragraph>Le mot-cl� <inline langage="rust">isize</inline> permet de laisser le compilateur choisir la taille en m�moire d'un entier <i>sign�</i>. (selon l'architecture de la machine sur laquelle le programme sera ex�cut�)</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-35" title="A quoi sert le mot-cl� usize&#160;?">A quoi sert le mot-cl� usize&#160;?</link></paragraph>
				</section>
				<section id="II-A-37">
					<title>Existe-t-il des outils de build pour le langage Rust&#160;?</title>
					<paragraph>Rust dispose d'un outil de d�veloppement multifonction nomm� Cargo.</paragraph>
					<paragraph>Cargo est en premier lieu un gestionnaire de paquets (qui vous permet donc de t�l�charger des modules Rust d�velopp�s par d'autres programmeurs) mais vous �paule �galement dans la gestion, la construction de vos projets, la cr�ation de vos manifest, etc.</paragraph>
					<paragraph>Un groupe de Q/R a �t� cr�� sur cette FAQ pr�sentant une liste non-exhaustive de commandes support�es par Cargo suivie d'un exemple d'utilisation (vous pourrez �galement retrouver des exemples dans le manuel officiel de l'outil(<inline langage="batch">$ man cargo</inline>))&#160;:</paragraph>
					<liste>
						<element>
							<link href="#LII-C-1" title="Comment cr�er un projet avec Cargo&#160;?">Comment cr�er un projet avec Cargo&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-2" title="Quel type de projet puis-je cr�er avec Cargo&#160;?">Quel type de projet puis-je cr�er avec Cargo&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-3" title="Comment compiler son projet&#160;?">Comment compiler son projet&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-4" title="Peut-on g�n�rer de la documentation avec Cargo&#160;?">Peut-on g�n�rer de la documentation avec Cargo&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-5" title="O� trouver de nouvelles biblioth�ques&#160;?">O� trouver de nouvelles biblioth�ques&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-6" title="Comment installer de nouvelles biblioth�ques&#160;?">Comment installer de nouvelles biblioth�ques&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-7" title="Comment publier sa biblioth�que faite-maison&#160;?">Comment publier sa biblioth�que faite-maison&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-8" title="Comment lancer des tests avec Cargo&#160;?">Comment lancer des tests avec Cargo&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-10" title="Comment cr�er ses benchmarks avec Cargo&#160;?">Comment cr�er ses benchmarks avec Cargo&#160;?</link>
						</element>
						<element>
							<link href="#LII-C-9" title="Comment mettre � jour mes biblioth�ques&#160;?">Comment mettre � jour mes biblioth�ques&#160;?</link>
						</element>
					</liste>
				</section>
				<section id="II-A-38">
					<title>Comment utiliser mes fonctions en dehors de mon module&#160;?</title>
					<paragraph>Pour utiliser vos fonctions en dehors de votre <inline langage="rust">mod</inline>ule, il vous faudra utiliser le mot-cl� <inline langage="rust">pub</inline>.</paragraph>
					<paragraph>Voir aussi&#160;: </paragraph>
					<paragraph>
						<link href="#LII-A-16" title="A quoi sert le mot-cl� pub&#160;?">A quoi sert le mot-cl� pub&#160;?</link>
					</paragraph>
					<paragraph>
						<link href="#LII-A-17" title="A quoi servent les mot-cl�s extern crate&#160;?">A quoi servent les mot-cl�s extern crate&#160;?</link>
					</paragraph>
				</section>
				<section id="II-A-39">
					<title>Comment comparer deux objets avec Rust&#160;?</title>
					<paragraph>Pour comparer deux objets avec Rust, vous pouvez utiliser la fonction <inline langage="rust">eq()</inline>&#160; impl�ment�e gr�ce au <inline langage="rust">trait</inline> <inline langage="rust">PartialEq</inline>.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code langage="rust" showLines="1" startLine="1" titre="Utilisation de la fonction eq()">fn main()
{
    let foo = 0;
    let bar = 0;
    let baz = foo.eq(&amp;bar); //true
    let bazz = 'Hello world&#160;!';
    let bazzz = 'Hello world&#160;!'.to_string();
    let bazzzz = bazz.eq(&amp;bazzz); //true
}</code>
					<paragraph>Voir aussi&#160;: <link href="#LII-A-45" title="Comment comparer deux objets d'une structure personnalis�e avec Rust&#160;?">Comment comparer deux objets d'une structure personnalis�e avec Rust&#160;?</link></paragraph>
				</section>
				<section id="II-A-40">
					<title>Qu'est-ce que le shadowing&#160;?</title>
					<paragraph>Le shadowing consiste � faire abstraction des identificateurs qui pourraient �tre identiques � ceux se trouvant dans un scope (�&#160;champ&#160;�) plus petit, ou �tranger � celui des autres identificateurs dans l'absolu.</paragraph>
					<paragraph>Exemple&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn main() -> ()
{
    let foo : &amp;str = "Hello";
    {
        let foo : &amp;str = "world!";
        println!("{}", &amp;foo);
    }
    println!("{}", &amp;foo);
}</code>
					<paragraph>La premi�re d�claration de foo a �t� �&#160;�clips�e&#160;� par celle se trouvant dans le deuxi�me scope. Lorsque cette derni�re a �t� d�truite (ou simplement mise hors d'acc�s, dans ce cas), la premi�re d�claration de foo a �t� de nouveau op�rationnelle.</paragraph>
					<paragraph>R�sultat&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Message sur la sortie standard">world!
Hello</code>
				</section>
				<section id="II-A-41">
					<title>Qu'est-ce que la destructuration&#160;?</title>
					<paragraph>Avec Rust, il est possible d'effectuer une �&#160;destructuration&#160;� sur certains types de donn�es, mais qu'est-ce que cela signifie exactement&#160;?</paragraph>
					<paragraph>Gr�ce au pattern matching, il est possible de cr�er, donc, des �&#160;mod�les&#160;� pour isoler une partie de la structure et ainsi v�rifier si notre entr�e correspond � nos attentes.</paragraph>
					<paragraph>Une destrucuration peut se faire sur&#160;:</paragraph>
					<paragraph>Les listes, les tuples&#160;;</paragraph>
					<paragraph>Les �num�rations&#160;;</paragraph>
					<paragraph>Les structures.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>
							<link href="#LII-A-42" title="Comment effectuer une destructuration sur une liste&#160;?">Comment effectuer une destructuration sur une liste&#160;?</link>
						</element>
						<element>
							<link href="#LII-A-43" title="Comment effectuer une destructuration sur une �num�ration ?">Comment effectuer une destructuration sur une �num�ration ?</link>
						</element>
						<element>
							<link href="#LII-A-44" title="Comment effectuer une destructuration sur une structure ?">Comment effectuer une destructuration sur une structure ?</link>
						</element>
					</liste>
				</section>
				<section id="II-A-42">
					<title>Comment effectuer une destructuration sur une liste&#160;?</title>
					<rich-imgtext type="info">
						<paragraph>Ce n'est pas encore possible. (<b>version</b> 1.12.1)</paragraph>
						<paragraph>Pour isoler une valeur comme nous allons le faire avec un tuple, ce n'est pas possible sans s'attirer les foudres du compilateur.</paragraph>
						<paragraph>La fonctionnalit� �tant, pour le moment, � l'�tat exp�rimental, elle n'est pas tol�r�e par le compilateur pour une utilisation courante.</paragraph>
						<paragraph>Nous ne parlerons donc ici que de la d�structuration des tuples.</paragraph>
					</rich-imgtext>
					<paragraph>Pour isoler une valeur contenu dans un tuple, il faut d'abord �crire son mod�le pour savoir o� le chercher.</paragraph>
					<paragraph>Par exemple, en assumant que nous cherchons une suite de chiffres dans un ordre croissant, il est simple de d�terminer si cette suite est dans le bon ordre ou non.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="D�structuration tuple">    let foo = ("one", "two", "three");
    let bar = ("two", "one", "three"); 
    
    match bar
    {
        ("one", x, "three") =>
        {
            if x == "two"
            {
                println!("tout est en ordre !");
            }
        },
        _ => println!("on dirait qu'il y a un probl�me dans votre tuple..."),
    }</code>
					<paragraph>Lorsque vous construisez un mod�le de ce type, gardez bien en t�te que la valeur la plus � gauche repr�sentera toujours la premi�re valeur du tuple, et celle plus � droite repr�sentera toujours la derni�re valeur du tuple.</paragraph>
					<paragraph>Rien ne vous emp�che donc de faire ceci&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Isolation de plusieurs valeurs">    let foo = ("one", "two", "three");
    let bar = ("two", "one", "three"); 
    
    match foo
    {
        ("one", x, y) =>
        {
            if (x, y) == ("two", "three") //on surveille plusieurs valeurs
            {
                println!("tout est en ordre !");
            }
        },
        _ => println!("on dirait qu'il y a un probl�me dans votre tuple..."),
    }</code>
				</section>
				<section id="II-A-43">
					<title>Comment effectuer une destructuration sur une �num�ration ?</title>
					<paragraph>Le pattern matching vous donne la possibilit� de �&#160;d�cortiquer&#160;� une �num�ration, vous permettant ainsi d'effectuer des tests complets.</paragraph>
					<paragraph>Voici un exemple&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Utilisation du pattern matching sur une �num�ration">pub enum Enum
{
    One,
    Two,
    Three,
    Four,
}

fn foo(arg: Enum) -> ()
{
    match arg
    {
        Enum::One => 
        {
            println!("One");
        },
        Enum::Two =>
        {
            println!("Two");
        },
        Enum::Three =>
        {
            println!("Three");
        },
        Enum::Four =>
        {
            println!("Four");
        },
    }
}

fn main()
{
    let (bar, baz, bazz, bazzz) = (Enum::One, Enum::Two, Enum::Three, Enum::Four);
    
    foo(bar);
    foo(baz);
    foo(bazz);
    foo(bazzz);
}</code>
				</section>
				<section id="II-A-44">
					<title>Comment effectuer une destructuration sur une structure ?</title>
					<paragraph>Tout d'abord, la question que nous pourrions nous poser est&#160;: en quoi consiste la destructuration sur une structure&#160;?</paragraph>
					<paragraph>L'id�e est d'isoler, encore une fois, les propri�t�s qui nous int�ressent.</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Destructuration">struct A
{
    x: String,
    y: String,
    z: String,
}

fn main() -> ()
{
    let foo = A {
                    x: "Hello".to_string(),
                    y: " ".to_string(),
                    z: "world!".to_string(),
                };
    let A {x: a, y: b, z: c} = foo; //on d�cortique les attributs de notre structure
    println!("{}{}{}", a, b, c); //puis on les utilise dans de nouvelles variables
}</code>
					<paragraph>Vous souhaiteriez omettre un attribut&#160;? Pas de probl�mes&#160;!</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Destructuration">    let foo = A {
                    x: "Hello".to_string(),
                    y: " ".to_string(),
                    z: "world!".to_string(),
                };
    let A {x: a, y: b, ..} = foo; //on d�cortique les attributs de notre structure
    println!("{}{}", a, b); //puis on les utilise dans de nouvelles variables</code>
					<paragraph>Vous pouvez �galement isoler ce style d'op�ration dans un scope plus petit (emp�chant l'utilisation des variables temporaires en dehors de ce dernier) comme ceci&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">    let foo = A {
                    x: "Hello".to_string(),
                    y: " ".to_string(),
                    z: "world!".to_string(),
                };
    {
        let A {x: a, y: b, z: c} = foo; //on d�cortique les attributs de notre structure
        println!("{}{}{}", a, b, c); //puis on les utilise dans de nouvelles variables
    }
    
    //a,b et c ne pourront plus �tre utilis�s � partir d'ici</code>
				</section>
				<section id="II-A-45">
					<title>Comment comparer deux objets d'une structure personnalis�e avec Rust&#160;?</title>
					<paragraph>La biblioth�que standard de Rust propose un(e) <inline langage="rust">trait</inline>/ interface nomm�(e) <inline langage="rust">PartialEq</inline> compos�e de deux fonctions&#160;:</paragraph>
					<liste type="1">
						<element>
							<inline langage="rust">fn eq(&amp;self, other&#160;: &amp;instance_de_la_meme_structure)</inline>
							<i>&#160;;</i>
						</element>
						<element>
							<inline langage="rust">fn ne(&amp;self, other&#160;: &amp;instance_de_la_meme_structure)&#160;</inline>
							<i>;</i>
						</element>
					</liste>
					<rich-imgtext type="warning">
						<paragraph>Comme il est stipul� dans la documentation officielle, vous n'�tes pas forc� d'impl�menter les deux fonctions&#160;: <inline langage="rust">fn ne()</inline> �tant simplement le contraire de <inline langage="rust">fn eq()</inline> et vice versa, il serait redondant de les impl�menter dans la m�me structure.</paragraph>
					</rich-imgtext>
					<paragraph>Ci-dessous figure un exemple complet d'impl�mentation&#160;:</paragraph>
					<code dissimulable="0" langage="rust" showLines="1" startLine="1" titre="Impl�mentation du trait PartialEq">struct Spartan&lt;'a>
{

    sid: i32, 
    name: &amp;'a str

}

impl&lt;'a> PartialEq for Spartan&lt;'a>
{
    fn eq(&amp;self, other: &amp;Spartan) -> bool
    {
        self.sid == other.sid
    }
}

impl&lt;'a> Spartan&lt;'a>
{
    
    pub fn new(sid: i32, name: &amp;str) -> Spartan
    {
        Spartan
        {
            sid: sid,
            name: name,
        }
    }
}
fn main()
{
    let (foo , bar) = (Spartan::new(117, "John"), Spartan::new(062, "Jorge"));
    
    if foo == bar 
    { 
        println!("foo equals bar"); 
    } 
    else 
    { 
        println!("foo not equals bar"); 
    }
}</code>
				</section>
				<section id="II-A-46">
					<title>Je n'arrive pas � utiliser les macros import�es par ma biblioth�que&#160;! Pourquoi&#160;?</title>
					<paragraph>Il se pourrait que vous ayez omis d'utiliser une annotation&#160;: <inline langage="rust">#[macro_use]</inline></paragraph>
					<paragraph>Cette derni�re permet d'exporter toutes les macros qui doivent �tre publiques pour �tre utilis�es � l'exterieur de la biblioth�que.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Exportation des macros">#[macro_use]
extern crate votre_lib;

fn main() -> ()
{
 votre_macro!();
}</code>
					<paragraph>Si vous ne parvenez toujours pas � les utiliser, il est possible que vous ayez omis l'annotation <inline langage="rust">#[macro_export]</inline> dans les modules comportant vos macros.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Pr�paration de l'exportation des macros">// dans le fichier lib.rs
#[macro_use]//bien pr�ciser que ce module utilise des macros
pub mod votre_conteneur
{
    #[macro_export]
    macro_rules! foo
    {
        () => ();
    }
    #[macro_export]
    macro_rules! bar
    {
        () => ();
    }
    #[macro_export]
    macro_rules! baz
    {
        () => ();
    }
}</code>
					<paragraph>Si votre probl�me persiste, je vous invite � vous rendre sur les forums figurant dans la rubrique programmation pour obtenir de l'aide. Pr�sentez clairement l'erreur que le compilateur vous renvoi dans votre post.</paragraph>
				</section>
				<section id="II-A-47">
					<title>A quoi servent les mot-cl�s if let&#160;?</title>
					<paragraph>La combinaison des deux mot-cl�s permet d'assigner, de mani�re concise, du contenu � une variable.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Assignation avec if let">fn main() -> ()
{
    let foo : Option&lt;String> = Some("Hello world!".to_string());
    let mut bar : bool = false;
    
    if let Some(content) = foo // si la variable foo contient quelque chose...
    {
        bar = true;
    }
    else
    {
        println!("foo's content is None");
    }
}</code>
					<paragraph>C'est un moyen simple et efficace d'assigner du contenu sans passer par le pattern matching.</paragraph>
				</section>
				<section id="II-A-48">
					<title>A quoi servent les mot-cl�s while let&#160;?</title>
					<paragraph>La combinaison des deux mot-cl�s permet d'effectuer des tests de mani�re concise et ainsi nous �viter de passer par le pattern matching lorsque �a n'est pas n�cessaire. (<inline langage="rust">while let</inline> peuvent s'av�rer tr�s utiles lorsqu'il faut tester � chaque it�ration si le fichier contient toujours quelque chose)</paragraph>
					<paragraph>
						<font color="#0000ff">[Exemple de la documentation officielle]</font>
					</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Cas d'utilisation de while let">let mut v = vec![1, 3, 5, 7, 11];
while let Some(x) = v.pop() {
    println!("{}", x);
}</code>
				</section>
			</section>
			<section id="II-B">
				<title>M�caniques et philosophies</title>
				<section id="II-B-1">
					<title>Gestion de la m�moire</title>
					<section id="II-B-1-a">
						<title>Le d�veloppeur doit-il g�rer la m�moire seul&#160;?</title>
						<paragraph>Cette FAQ dispose de trois Q/R abordant trois concepts distincts (mais se compl�tant) gravitant autour de la gestion de la m�moire avec le langage Rust.</paragraph>
						<paragraph>Par souci de concision, les Q/R ci-dessous ne retiennent que l'essentiel de chaque concepts&#160;:</paragraph>
						<liste type="1">
							<element>
								<link href="#LII-B-1-b" title="Qu'est-ce que �&#160;l'ownership&#160;�&#160;?">Qu'est-ce que �&#160;l'ownership&#160;�&#160;?</link>
							</element>
							<element>
								<link href="#LII-B-1-c" title="Qu'est-ce que le concept de �&#160;borrowing&#160;�&#160;?">Qu'est-ce que le concept de �&#160;borrowing&#160;�&#160;?</link>
							</element>
							<element>
								<link href="#LII-B-1-d" title="Qu'est-ce que le concept de �&#160;lifetime&#160;�&#160;?">Qu'est-ce que le concept de �&#160;lifetime&#160;�&#160;?</link>
							</element>
						</liste>
					</section>
					<section id="II-B-1-b">
						<title>Qu'est-ce que �&#160;l'ownership&#160;�&#160;?</title>
						<rich-imgtext type="info">
							<paragraph>Cette Q/R abordant un concept propre au langage Rust, certains points pourraient encore vous para�tre obscures apr�s votre lecture. Si c'est le cas, vous pouvez vous reporter directement � la section, d�di�e � ce sujet, de la <link href="https://doc.rust-lang.org/book/ownership.html" langue="En" target="_blank" title="Ouvrir un nouvel onglet">documentation officielle</link> du langage.</paragraph>
						</rich-imgtext>
						<paragraph>Si l'on fait abstraction du contexte dans lequel est employ� ce terme (en l'occurrence, la programmation), nous pourrions le traduire de cette fa�on&#160;: �&#160;propri�t�&#160;�, �&#160;possession&#160;�.</paragraph>
						<paragraph>Nous verrons un peu plus bas que le fonctionnement de ce m�canisme n'est pas si �tranger au sens litt�ral du terme.</paragraph>
						<paragraph>
							<b>Introduction</b>
						</paragraph>
						<paragraph>Rust est muni d'un syst�me �&#160;d'appartenance&#160;� qui permet d'�carter les conflits les plus communs lorsqu'une ressource est utilis�e � plusieurs endroits.</paragraph>
						<paragraph>Bien que ce dernier soit tr�s pratique, il demande d'avoir une certaine rigueur quant � la d�claration de nos ressources, sans quoi vous risqueriez de vous attirer les foudres du compilateur.</paragraph>
						<paragraph>Pour cela, voici un exemple d'erreur typique lorsque l'on d�bute sans r�ellement conna�tre les t�ches effectu�es par le �&#160;ramasse-miette&#160;�&#160;:</paragraph>
						<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Transfert par copie">fn main()
{
    let foo : String = String::from("Hello world!");
    let bar : String = foo;
    let baz : String = foo; //erreur la ressource a �t� �&#160;d�plac�e&#160;�
}</code>
						<paragraph>Renvoyant une erreur de ce style&#160;:</paragraph>
						<code langage="rust" showLines="1" startLine="1" titre="Message d'erreur">error: use of moved value: `foo`</code>
						<paragraph>C'est un exemple simple, mais qui (dans nos d�buts) peut �tre une v�ritable plaie&#160;: on ne comprend pas d'o� vient l'erreur - tout est syntaxiquement correct, mais le compilateur n'a pas l'air satisfait.</paragraph>
						<paragraph>C'est simple&#160;:</paragraph>
						<paragraph>La variable foo �tant un pointeur contenant l'adresse m�moire d'un objet String, il est courant de dire qu'il poss�de �&#160;l'ownership&#160;�, il est le seul � pouvoir utiliser cette ressource.</paragraph>
						<paragraph>C'est en copiant les informations relatives � l'objet String (en �&#160;d�placant&#160;� ces informations dans une nouvelle variable, donc) que le <i>garbage</i> <i>collector</i> va faire son travail&#160;: d�truire le pointeur <i>foo</i> pour attribuer �&#160;l'ownership&#160;� au nouveau pointeur de la ressource&#160;: <i>bar</i>.</paragraph>
						<paragraph>C'est lorsque la variable <i>baz</i> essaie de copier les informations de <i>foo</i> que l'erreur survient&#160;: <i>foo</i> a d�j� �t� d�truit par le <i>garbage</i> <i>collector</i>.</paragraph>
						<rich-imgtext type="info">
							<paragraph>Lorsque la ressource est dite �&#160;d�plac�e&#160;� ce n'est pas l'objet lui-m�me qu'il l'est, rien n'est recr�� lors de cette destruction de pointeurs. On se contente ici de �&#160;binder&#160;� (rattacher) la r�f�rence de l'objet � un nouveau pointeur&#160;: il n'y a donc pas d'effets de bord ind�sirables. (temps de cr�ation, consommation CPU)</paragraph>
						</rich-imgtext>
						<paragraph>Pour rem�dier au probl�me, il aurait simplement suffit de copier <i>bar</i> de cette mani�re&#160;:</paragraph>
						<code langage="rust" showLines="1" startLine="1">fn main()
{
    let foo : String = String::from("Hello world!");
    let bar : String = foo;
    let baz : &amp;String = &amp;bar; //on r�cup�re une r�f�rence
}</code>
						<paragraph>Tout est en r�gle, le compilateur ne r�le plus, et si vous souhaitez afficher votre cha�ne de caract�res sur la sortie standard, rien ne vous en emp�che&#160;!</paragraph>
						<rich-imgtext type="warning">
							<paragraph><b>Attention</b> cependant&#160;:</paragraph>
							<paragraph>Cette r�gle ne s'applique qu'aux ressources dynamiques&#160;; Etant prompt � �tre r�f�renc� � plusieurs endroits en m�me temps, <i>Rust s'assure de toujours fournir la r�f�rence la plus r�cente de la ressource</i>.</paragraph>
							<paragraph>Pour les ressources statiques, leurs places dans la m�moire sont d�j� "pr�vues" donc pas de probl�mes.</paragraph>
						</rich-imgtext>
						<paragraph>Vous pouvez tr�s bien �crire ceci&#160;:</paragraph>
						<code langage="rust" showLines="1" startLine="1" titre="contre-exemple">fn main()
{
    let foo = 42;
    let bar = foo;
    let baz = foo;
}</code>
						<paragraph>
							<b>Quid des fonctions&#160;?</b>
						</paragraph>
						<paragraph>Les fonctions ob�issent aux m�mes r�gles que les pointeurs&#160;:</paragraph>
						<paragraph>Lorsqu'une ressource est pass�e en param�tre par copie, la fonction �&#160;poss�de&#160;� la ressource, m�me lorsqu'elle a termin� de s'ex�cuter.</paragraph>
						<rich-imgtext type="info">
							<paragraph>Si la ressource en question a �t� cr��e dynamiquement, elle sera syst�matiquement d�truite lorsque la fonction aura termin� de s'ex�cuter&#160;; Sinon, elle devient simplement inaccessible pour le restant de l'ex�cution.</paragraph>
						</rich-imgtext>
						<paragraph>Exemple&#160;:</paragraph>
						<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn my_func(my_string: String)
{
    let chars = my_string.chars();
    for letter in chars 
    {
        println!("{}", &amp;letter);
    }
}
fn main()
{
    let foo : String = String::from("The cake is a lie!");
    my_func(foo);
    
    let chars = foo.chars(); //error
    
}</code>
						<paragraph>Vous remarquerez donc ici que le pointeur <b>foo</b> a �t� d�truit, la copie de la cha�ne de caract�res appartient d�sormais � la fonction.</paragraph>
						<rich-imgtext type="warning">
							<paragraph>Ne vous attardez pas sur le contenu de la fonction myfunc()&#160;;</paragraph>
							<paragraph>Ce n'est qu'un exemple parmi tant d'autres, gardez simplement � l'esprit que si la ressource est pass�e en param�tre par copie, le pointeur vers cette derni�re est d�truit.</paragraph>
						</rich-imgtext>
						<paragraph>Voir aussi&#160;: <link href="#LII-B-1-c" title="Qu'est-ce que le concept de �&#160;borrowing&#160;�&#160;?">Qu'est-ce que le concept de �&#160;borrowing&#160;�&#160;?</link></paragraph>
					</section>
					<section id="II-B-1-c">
						<title>Qu'est-ce que le concept de �&#160;borrowing&#160;�&#160;?</title>
						<rich-imgtext type="info">
							<paragraph>Cette Q/R abordant un concept propre au langage Rust, certains points pourraient encore vous para�tre obscures apr�s votre lecture. Si c'est le cas, vous pouvez vous reporter directement � la section, d�di�e � ce sujet, de la <link href="https://doc.rust-lang.org/book/ownership.html" langue="En" target="_blank" title="Ouvrir un nouvel onglet">documentation officielle</link> du langage.</paragraph>
						</rich-imgtext>
						<paragraph>Il est courant de devoir partager une ressource entre plusieurs pointeurs pour effectuer diverses t�ches.</paragraph>
						<paragraph>Toutefois, plus une ressource est sollicit�e, plus il y a de chance qu'elle soit <i>d�synchronis�e/invalid�e</i> � un moment ou un autre. (c'est encore plus fr�quent lorsque cette derni�re est sollicit�e par plusieurs fils d'ex�cution)</paragraph>
						<paragraph>Rust rem�die � ce probl�me gr�ce au �&#160;borrow checking&#160;�, un syst�me d'emprunts cr�ant en quelque sorte des <i>mutex</i> charg�s de limiter l'acc�s � une ressource et ainsi �viter les risques d'�critures simultan�es.</paragraph>
						<paragraph>Le borrow checker fera respecter ces trois r�gles (que vous pouvez retrouver dans la documentation officielle)&#160;:</paragraph>
						<liste type="1">
							<element>Une (ou plusieurs) variable  peut emprunter la ressource en lecture. (r�f�rence immuable)</element>
							<element>Un, et <b>seulement un</b>, pointeur peut disposer d'un acc�s en �criture sur la ressource.</element>
							<element>Vous ne pouvez pas acc�der � la ressource en lecture et en �criture en m�me temps, exemple&#160;:</element>
						</liste>
						<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Emprunt interdit">fn main() 
{
    let mut foo = 117;
    let bar = &amp;mut foo;
    let baz = &amp;foo; //erreur

}</code>
						<paragraph>Ou&#160;:</paragraph>
						<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Deux acc�s en �criture">fn main() 
{
    let mut foo = 117;
    let bar = &amp;mut foo;
    let baz = &amp;mut foo; //erreur
}</code>
					</section>
					<section id="II-B-1-d">
						<title>Qu'est-ce que le concept de �&#160;lifetime&#160;�&#160;?</title>
						<rich-imgtext type="info">
							<paragraph>Cette Q/R abordant un concept propre au langage Rust, certains points pourraient encore vous para�tre obscures apr�s votre lecture. Si c'est le cas, vous pouvez vous reporter directement � la section, d�di�e � ce sujet, de la <link href="https://doc.rust-lang.org/book/ownership.html" langue="En" target="_blank" title="Ouvrir un nouvel onglet">documentation officielle</link> du langage.</paragraph>
						</rich-imgtext>
						<paragraph>
							<b>Introduction</b>
						</paragraph>
						<paragraph>Comme tous langages (sauf exception que nous pourrions ignorer), Rust dispose d'un syst�me de dur�e de vie.</paragraph>
						<paragraph>Toutefois, il fait preuve d'une grande rigourosit� quant � la destruction des ressources dynamiques et � �&#160;l'isolement&#160;� des ressources statiques apr�s utilisation.</paragraph>
						<paragraph>Voici un exemple&#160;:</paragraph>
						<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="D�monstration des scopes">fn main()
{
    let mut foo : String = "Hello world!".to_string(); //Le scope A commence ici
    let bar : String = "Goodbye, friend !".to_string();//Le scope B commence ici
    foo = bar;// bar d�truit, le scope B s'arr�te l�
    println!("{}", &amp;bar);
} // Le Scope A s'arr�te ici</code>
						<paragraph>On remarque � la suite de cet exemple que le concept de �&#160;scope&#160;� (contexte) n'est pas � l'�chelle d'une fonction, mais bien des variables, incitant le d�veloppeur � d�clarer et initialiser sa ressource uniquement lorsqu'il en a besoin.</paragraph>
						<paragraph>
							<b>Quid des r�f�rences&#160;? </b>
						</paragraph>
						<paragraph>Le concept de dur�e de vie d�di�e aux r�f�rences peut parfois d�router, surtout lorsqu'il faut expliciter certains tags (repr�sentants des dur�es de vie) au compilateur lorsqu'il nous l'impose et que l'on ne comprend pas bien pourquoi.</paragraph>
						<paragraph>Les r�f�rences n'�chappent pas � la r�gle, elles aussi ont des dur�es vie bien d�termin�es&#160;; En r�gle g�n�rale, il n'est pas utile (voire interdit) au d�veloppeur d'expliciter les tags qui permettent au compilateur de �&#160;suivre&#160;� chaque r�f�rence durant son utilisation.</paragraph>
						<paragraph>Cependant, lorsque l'une d'elles est pass�e en param�tre � une fonction, il peut parfois �tre n�cessaire de tagger celles qui survivront au moins � l'ex�cution de la fonction. (ne serait-ce que par souci de claret�)</paragraph>
						<paragraph>Voici un exemple qui pourrait vous �pauler&#160;: (attention � bien lire les commentaires)</paragraph>
						<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn foo(phrase: &amp;str) -> () //aucune r�f�rence ne survi, donc pas la peine de l'annoter
{
    println!("{}", &amp;phrase);
}

fn bar&lt;'a>(phrase: &amp;'a mut String, word: &amp;str) -> &amp;'a String //une r�f�rence va survivre il faut maintenant savoir laquelle
{
    phrase.push_str(word);
    return phrase;
}//La r�f�rence qui survivra sera donc �&#160;phrase&#160;�, elle dispose donc de la dur�e de vie 'a.

fn main()
{
  let mut baz  : String = "Hello ".to_string();
  let word : &amp;str   = "world!";
  let bazz = bar(&amp;mut baz, word); //ce que contient la varialbe bazz ne peut �tre acc�d� qu'en lecture
  println!("{}", &amp;bazz); //nous affichons nos caract�res sur la sortie standard
}</code>
						<paragraph>En revanche, ce n'est pas un cas commun, nous vous invitons donc � vous tourner vers la documentation officielle ou � exp�rimenter par vous-m�me.</paragraph>
						<paragraph>
							<b>Que faut-il retenir&#160;?</b>
						</paragraph>
						<paragraph>Pour faire simple, il faut retenir que&#160;:</paragraph>
						<liste>
							<element>Chaque variable cr�� un nouveau scope lors de sa d�claration&#160;;</element>
							<element>Toutes variables retrouv�es dans le scope d'une autre verra sa dur�e de vie plus courte que cette derni�re&#160;;</element>
							<element>A propos des r�f�rences pass�es en param�tres, seules les r�f�rences survivant au moins � la fin de l'ex�cution de la fonction devraient �tre annot�es.</element>
						</liste>
						<paragraph>Voir aussi&#160;:</paragraph>
						<paragraph>
							<link href="https://doc.rust-lang.org/nomicon/lifetimes.html" target="_blank">Le Rustonomicon</link>
						</paragraph>
						<paragraph>
							<link href="https://doc.rust-lang.org/book/lifetimes.html" target="_blank">La section d�di�e du livre</link>
						</paragraph>
					</section>
					<section id="II-B-1-e">
						<title>Comment �tendre un trait sur un autre trait&#160;?</title>
					</section>
				</section>
			</section>
			<section id="II-C">
				<title>Outils de build</title>
				<section id="II-C-1">
					<title>Comment cr�er un projet avec Cargo&#160;?</title>
					<paragraph>Pour cr�er un nouveau projet avec Cargo, v�rifiez d'abord qu'il est <i>install�</i> sur votre machine&#160;:</paragraph>
					<paragraph>
						<inline langage="bash">$ cargo -V</inline>
					</paragraph>
					<paragraph>Puis&#160;:</paragraph>
					<paragraph>
						<inline langage="rust">$ cargo new nom_de_votre_repertoire</inline>
					</paragraph>
					<paragraph>Vous devriez voir se g�n�rer un dossier avec le nom assign� dans lequel se trouvera un r�pertoire nomm� src et un manifest nomm� <i>Cargo.toml</i>.</paragraph>
				</section>
				<section id="II-C-2">
					<title>Quel type de projet puis-je cr�er avec Cargo&#160;?</title>
					<paragraph>Lorsque vous lancez la commande de g�n�ration (telle qu'elle), votre projet est g�n�r� en mode �&#160;biblioth�que&#160;�, et n'est donc pas destin� � �tre directement ex�cut�.</paragraph>
					<paragraph>Si vous souhaitez g�n�rer un projet en mode �&#160;ex�cutable&#160;�, il suffit de le pr�ciser dans la commande&#160;:</paragraph>
					<paragraph>
						<inline langage="rust">$ cargo new folder_name  --bin</inline>
					</paragraph>
					<paragraph>Par d�faut, le nom du r�pertoire racine sera �galement le nom de votre biblioth�que si elle devait �tre identifi�e par d'autres utilisateurs dans le but de la t�l�charger. Si vous souhaitez lui attribuer un autre nom, vous pouvez �galement le sp�cifier dans la commande&#160;:</paragraph>
					<paragraph>
						<inline langage="rust">$ cargo new folder_name --name another_name  --bin</inline>
					</paragraph>
					<paragraph>Le manifest sera modifi� en cons�quence.</paragraph>
				</section>
				<section id="II-C-3">
					<title>Comment compiler son projet&#160;?</title>
					<paragraph>Pour compiler votre projet, vous devez vous trouver � la racine de ce dernier.</paragraph>
					<paragraph>Une fois que c'est fait, il vous suffit de lancer la commande suivante&#160;:</paragraph>
					<paragraph>
						<inline langage="rust">$ cargo build</inline>
					</paragraph>
					<rich-imgtext type="info">
						<paragraph>Par d�faut, cargo compile votre projet en mode �&#160;debug&#160;�, emp�chant le compilateur d'effectuer des optimisations trop agressives.</paragraph>
						<paragraph>Lorsque vous souhaiterez envoyer votre binaire en production, vous pouvez utiliser l'option �&#160;<inline langage="bash">--release</inline>&#160;� comme ceci&#160;:</paragraph>
						<paragraph>
							<inline langage="rust">$ cargo build --release </inline>
						</paragraph>
					</rich-imgtext>
				</section>
				<section id="II-C-4">
					<title>Peut-on g�n�rer de la documentation avec Cargo&#160;?</title>
					<paragraph>Bien s�r&#160;!</paragraph>
					<paragraph>Il suffit de lancer la commande $ cargo doc � la racine de votre projet.</paragraph>
					<paragraph>La documentation se trouvera dans le dossier <inline langage="bash">./target/doc/&#8230;</inline></paragraph>
					<paragraph>
						<b>O� est l'index de mon site&#160;?</b>
					</paragraph>
					<paragraph>Il se trouve dans le r�pertoire portant le nom de votre projet.</paragraph>
					<rich-imgtext type="info">
						<paragraph>Notez que si vous avez ajout� des d�pendences � votre projet, cargo g�n�rera �galement la documentation de celles-ci. (assurant alors un site uniforme et complet)</paragraph>
					</rich-imgtext>
				</section>
				<section id="II-C-5">
					<title>O� trouver de nouvelles biblioth�ques&#160;?</title>
					<paragraph>Vous pouvez trouver d'autres biblioth�ques sur le <link href="https://crates.io/crates">site officiel</link> de Cargo.</paragraph>
					<paragraph>Voir aussi&#160;: <link href="#LII-C-6" title="Comment installer de nouvelles biblioth�ques&#160;?">Comment installer de nouvelles biblioth�ques&#160;?</link></paragraph>
				</section>
				<section id="II-C-6">
					<title>Comment installer de nouvelles biblioth�ques&#160;?</title>
					<paragraph>Il y a deux mani�res de faire&#160;:</paragraph>
					<liste type="1">
						<element>Les t�l�charger � partir de <link href="https://crates.io/crates" target="_blank">crate.io</link>&#160;;</element>
						<element>Les t�l�charger directement � partir de leur d�p�t github.</element>
					</liste>
					<paragraph>C'est selon vos pr�f�rences. (et surtout selon la disponibilit� de la ressource)</paragraph>
					<paragraph>Donc pour la premi�re fa�on, rien de plus simple&#160;:</paragraph>
					<liste>
						<element>Vous cherchez la biblioth�que que vous d�sirez sur le site&#160;;</element>
						<element>Vous renseignez son nom dans votre manifest&#160;;</element>
						<element>Compilez&#160;;</element>
						<element>C'est pr�t&#160;!</element>
					</liste>
					<paragraph>Pour la seconde&#160;:</paragraph>
					<liste>
						<element>Cherchez le d�p�t github de la biblioth�que d�sir�e&#160;;</element>
						<element>Notez le nom que porte cette biblioth�que dans son manifest&#160;;</element>
						<element>Puis ajoutez cette ligne dans vos d�pendences&#160;: <inline langage="rust">lib_name = {git = "url du d�p�t"&#160;}</inline>&#160;;</element>
						<element>Compilez&#160;;</element>
						<element>C'est pr�t&#160;!</element>
					</liste>
				</section>
				<section id="II-C-7">
					<title>Comment publier sa biblioth�que faite-maison&#160;?</title>
					<paragraph>Les proc�dures �tant tr�s bien expliqu�es sur le site de <link href="http://crates.io/">crates.io</link>, nous vous invitons � vous rendre dans la <link href="http://doc.crates.io/crates-io.html">section d�di�e</link>.</paragraph>
					<paragraph>Si vous souhaitez malgr� tout lire les proc�dures sur la FAQ, en voici une traduction&#160;:</paragraph>
					<paragraph>Une fois que vous avez une biblioth�que que vous souhaiteriez partager avec le reste du monde, il est temps de la publier sur <link href="http://crates.io/">crates.io</link>&#160;!</paragraph>
					<paragraph>La publication d'un paquet est effective lorsqu'il est upload� pour �tre h�berg� par <link href="http://crates.io/">crates.io</link>.</paragraph>
					<rich-imgtext type="warning">
						<paragraph>R�fl�chissez avant de publier votre paquet, car sa publication est <b>permanente</b>.</paragraph>
						<paragraph>La version publi�e ne pourra <b>jamais</b> �tre �cras�e par une autre, et le code ne pourra �tre supprim�.</paragraph>
						<paragraph>En revanche, le nombre de versions publi�es n'est pas limit�.</paragraph>
					</rich-imgtext>
					<paragraph>
						<b>Avant votre premi�re publication</b>
					</paragraph>
					<paragraph>Premi�rement, vous allez avoir besoin d'un compte sur crates.io pour recevoir un �&#160;token&#160;� (jeton) provenant de l'API. Pour faire ceci, visitez la page d'accueil et enregistrez-vous via votre compte Github. Ensuite, rendez-vous dans vos options de compte, et lancez la commande $ cargo login suivi de votre token.</paragraph>
					<code dissimulable="1" langage="bash" showLines="1" startLine="1">$ cargo login abcdefghijklmnopqrstuvwxyz012345</code>
					<paragraph>Cette commande va informer Cargo que vous d�tenez un token provenant de l'API du site. (il est enregistr� dans le chemin suivant&#160;: ~/.cargo/config.)</paragraph>
					<paragraph>Ce token doit rester secret et ne devrait �tre partag� avec personne. Si vous le perdez d'une quelconque mani�re, r�g�n�rez-le imm�diatement.</paragraph>
					<paragraph>
						<b>Avant la publication du paquet</b>
					</paragraph>
					<paragraph>Gardez en t�te que le nom de chaque paquet est allou� en respectant la r�gle du �&#160;premier arriv�, premier servi&#160;�. Une fois que vous avez choisi un nom, il ne pourra plus �tre utilis� pour un autre paquet.</paragraph>
					<paragraph>
						<b>Empaqueter le projet</b>
					</paragraph>
					<paragraph>La prochaine �tape consiste � empaqueter votre projet de mani�re � �tre intelligible pour crates.io. Pour rem�dier � cela, nous allons utiliser la commande cargo package. Votre projet sera donc empaqueter sous la format *.crate et se trouvera dans le r�pertoire target/package/.</paragraph>
					<code langage="bash" showLines="1" startLine="1">$ cargo package</code>
					<paragraph>En plus de cela, la commande package est capable de v�rifier l'int�grit� de votre projet en d�paquetant votre *.crate et le recompiler. Si la phase de v�rification se passe sans probl�me, rien ne devrait �tre affich� dans votre terminal. </paragraph>
					<paragraph>Toutefois, si vous souhaitez d�sactiver cette v�rification avant l'envoi, il vous suffit d'ajouter le flag --no-verify.</paragraph>
					<paragraph>Cargo va ignorer automatiquement tous les fichiers ignor�s par votre syst�me de versionning, mais si vous voulez sp�cifier un type de fichiers en particulier, vous pouvez utiliser le mot-cl� exclude dans votre manifest&#160;:</paragraph>
					<paragraph>[Exemple tir� de la <link href="http://doc.crates.io/crates-io.html">documentation officielle</link> de l'outil]</paragraph>
					<code langage="text" showLines="1" startLine="1">[package]
# ...
exclude = [
    "public/assets/*",
    "videos/*",
]</code>
					<paragraph>La syntaxe de chaque �l�ment dans ce tableau est ce que glob accepte. Si vous souhaitez cr�er une whitelist au lieu d'une blacklist, vous pouvez utiliser le mot-cl� include.</paragraph>
					<paragraph>[Exemple tir� de la <link href="http://doc.crates.io/crates-io.html">documentation officielle</link> de l'outil]</paragraph>
					<code langage="text" showLines="1" startLine="1">[package]
# ...
include = [
    "**/*.rs",
    "Cargo.toml",
]</code>
					<paragraph>Maintenant que nous avons un fichier *.crate pr�t � y aller, il peut �tre upload� sur crates.io gr�ce � la commande cargo publish. C'est tout, vous venez de publier votre premier paquet&#160;!</paragraph>
					<code langage="bash" showLines="1" startLine="1">$ cargo publish</code>
					<paragraph>Si vous venez � oublier de lancer la commande <inline langage="bash">cargo package</inline>, <inline langage="bash">cargo publish</inline> le fera � votre place et v�rifiera l'int�grit� de votre projet avant de lancer l'�tape de publication.</paragraph>
					<rich-imgtext type="info">
						<paragraph>Il se pourrait que la commande publish vous refuse votre premi�re publication. Pas de panique, ce n'est pas tr�s grave.</paragraph>
						<paragraph>Votre paquet, pour �tre diff�renci� des autres, doit compter un certain nombre de m�tadonn�es pour renseigner vos futurs utilisateurs sur les tenants et aboutissants de votre projet, comme la licence par exemple.</paragraph>
						<paragraph>Pour ceci, vous pouvez vous rendre <link href="http://doc.crates.io/manifest.html#package-metadata">ici</link>, et ainsi visionner un exemple simple des m�tadonn�es � renseigner.</paragraph>
						<paragraph>Relancez votre proc�dure cargo publish, vous ne devriez plus avoir de probl�me.</paragraph>
					</rich-imgtext>
					<paragraph>Un probl�me pour acc�der � l'exemple&#160;? En voici un autre&#160;:</paragraph>
					<code dissimulable="1" langage="toml" showLines="1" startLine="1" titre="Arch�type de manifest valide">[package]
name = "verbose_bird"
version = "0.3.2"
authors = ["Songbird0 &lt;chaacygg@gmail.com>"]
description = "An awesome homemade loggers pack."
documentation = "https://github.com/Songbird0/Verbose_Bird/blob/master/src/README.md"
homepage = "https://github.com/Songbird0/Verbose_Bird"
repository = "https://github.com/Songbird0/Verbose_Bird"

readme = "README.md"

keywords = ["Rust", "log", "loggers", "pack"]

license = "GPL-3.0"

license-file = "LICENSE.md"

[dependencies]</code>
					<rich-imgtext type="warning">
						<paragraph>Il se peut que vous rencontriez �galement des probl�mes avec l'entr�e �&#160;license = ...&#160;� vous informant que le nom de licence entr� n'est pas valide.</paragraph>
						<paragraph>Pour r�gler le souci rendez-vous sur <link href="https://opensource.org/licenses/alphabetical" langue="En" target="_blank" title="Ouvrir un nouvel onglet">opensource.org</link> et visionner les noms raccourcis entre parenth�ses de chaque licence.</paragraph>
					</rich-imgtext>
				</section>
				<section id="II-C-8">
					<title>Comment lancer des tests avec Cargo&#160;?</title>
					<paragraph>Pour lancer un test avec cargo, il vous faudra utiliser l'attribut <inline langage="rust">#[test]</inline> et, �videmment, la commande <inline langage="rust">$ cargo test</inline>.</paragraph>
					<paragraph>Voici un exemple simple de tests&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">#[cfg(test)]
mod oo_tests
{
    struct Alice;
    use loggers_pack::oop::Logger;
    impl Logger for Alice{/*...*/}

    #[test]
    fn pack_logger_oop_info()
    {
        Alice::info("@Alice", "Hello, I'm Alice ", "Peterson !");
    }

    #[test]
    fn pack_logger_oop_wan()
    {
        Alice::warn("@Alice", "Hello, I'm Alice ", "Peterson !");
    }

    #[test]
    fn pack_logger_oop_error()
    {
        Alice::error("@Alice", "Hello, I'm Alice ", "Peterson !");
    }

    #[test]
    fn pack_logger_oop_success()
    {
        Alice::success("@Alice", "Hello, I'm Alice ", "Peterson !");
    }
}</code>
					<paragraph>Chaque fonction annot�e par l'attribut <inline langage="rust">#[test]</inline> sera compil�e durant la phase de test.</paragraph>
					<rich-imgtext type="error">
						<paragraph>La version 1.9.0 de Rust comporte un bogue au niveau des tests. Dans cette version, toutes les fonctions annot�es <inline langage="rust">#[test]</inline> doivent �tre encapsul�es dans un module. Ce n'est bien entendu plus le cas en 1.12.0.<br/>
		Si vous rencontrez ce probl�me, nous vous conseillons de mettre � jour votre SDK.</paragraph>
					</rich-imgtext>
				</section>
				<section id="II-C-9">
					<title>Comment mettre � jour mes biblioth�ques&#160;?</title>
					<paragraph>Pour mettre � jour vos d�pendences, il vous suffit d'utiliser la commande&#160;: <inline langage="rust">$ cargo update</inline>.</paragraph>
					<paragraph>Vous pouvez �galement pr�ciser quelle biblioth�que mettre � jour s�par�ment en utilisation l'option <inline langage="rust">$ cargo update --precise nom_dep</inline></paragraph>
					<rich-imgtext type="warning">
						<paragraph>Faites tout de m�me attention avant de mettre � jour vos d�pendences. Il se pourrait que les nouvelles versions cassent la compatibilit� ascendante.</paragraph>
					</rich-imgtext>
				</section>
				<section id="II-C-10">
					<title>Comment cr�er ses benchmarks avec Cargo&#160;?</title>
					<rich-imgtext type="warning">
						<paragraph>Avant toute chose, il est bon de savoir que la stabilit� du module supportant les benchmarks est encore discut�e au sein m�me de l'�quipe charg�e du d�veloppement de Rust.</paragraph>
						<paragraph>N'�tant pas dispos� � fonctionner en production, vous devrez avoir recours � un paquet qui ne se trouve pas dans la biblioth�que standard, mais sur <link href="./fichiers/crates.io" target="_blank" title="Ouvrir un nouvel onglet">crates.io</link>.</paragraph>
					</rich-imgtext>
					<paragraph>Pour cr�er nos benchmark, donc, nous allons utiliser le paquet <link href="https://crates.io/crates/bencher">bencher</link>.</paragraph>
					<paragraph>Ce module �tait premi�rement connu sous le nom test puis bencher qui sera port� en tant que d�pendance externe pour �viter les effets de bord dans les versions stables du langage.</paragraph>
					<code dissimulable="1" langage="toml" showLines="1" startLine="1" titre="Fichier Cargo.toml">[package]
name = "awesome_tests"
version = "0.1.0"
authors = ["Songbird0 &lt;chaacygg@gmail.com>"]

[dependencies]

bencher = "0.1.1"

[[bench]]
name = "my_bench"
harness = false</code>
					<paragraph>Voici un exemple basique de benchmark pour une fonction qui recherche le mot le plus court d'une phrase&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="find_short function benchmark">#[macro_use]
extern crate bencher;
use bencher::Bencher;

fn find_short(s: &amp;str) -> usize {
  let splitting : Vec&lt;&amp;str> = s.split_whitespace().collect();
  let mut shortest_len : usize = 0;
  let mut i : usize = 0;
  while(i &lt; splitting.len())
  {
      if(i == 0)
      {
          shortest_len = splitting[0].len();
      }
      else
      {
          if(splitting[i].len() &lt; shortest_len)
          {
              shortest_len = splitting[i].len();
          }
      }
      i += 1;
  }
  return shortest_len;
}

fn bench_find_short(b: &amp;mut Bencher) {
  b.iter(|| find_short("Hello darkness my old friend"));
}

benchmark_group!(my_bench, bench_find_short);
benchmark_main!(my_bench);</code>
				</section>
				<section id="II-C-11">
					<title>A quoi sert benchmark_group!&#160;?</title>
					<paragraph>La macro <inline langage="rust">bencmark_group!</inline> sert a cr�er des �&#160;groupes&#160;� de fonctions � mesurer lors de l'ex�cution de la commande <inline langage="bash">cargo bench</inline>. </paragraph>
				</section>
				<section id="II-C-12">
					<title>A quoi sert benchmark_main!&#160;?</title>
					<paragraph>La macro <inline langage="rust">benchmark_main!</inline> permet de cr�er une fonction main contenant toutes les fonctions � �&#160;benmarker&#160;�.</paragraph>
				</section>
			</section>
			<section id="II-D">
				<title>Gestion des erreurs</title>
				<section id="II-D-1">
					<title>Comment s'effectue la gestion des erreurs avec Rust&#160;?</title>
					<paragraph>Tout comme les langages imp�ratifs classiques (e.g. C), Rust ne g�re pas les erreurs gr�ce � un syst�me �&#160;d'exceptions&#160;� comme nous pourrions retrouver dans des langages plus orient�s objets, mais gr�ce au contenu renvoy� en sortie de fonction.</paragraph>
					<paragraph>Plusieurs fonctions (et macros) sont d'ailleurs d�di�es � cette gestion (e.g. <inline langage="rust">panic!</inline>, <inline langage="rust">unwrap()</inline> (et ses d�riv�s), <inline langage="rust">and_then()</inline>) permettant ainsi de rattraper (d'une mani�re plus ou moins fine) la situation lorsque les conditions impos�es par vos soins ne sont pas respect�es.</paragraph>
					<paragraph>Cette section regroupe donc un certain nombre de Q/R qui pourrait vous aider � mieux cerner ce syst�me de gestion&#160;:</paragraph>
					<liste>
						<element>
							<link href="#LII-D-4" title="A quoi sert la macro panic&#160;!&#160;?">A quoi sert la macro panic!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-5" title="A quoi sert la m�thode unwrap&#160;?">A quoi sert la m�thode unwrap ?</link>
						</element>
						<element>
							<link href="#LII-D-6" title="A quoi sert la m�thode unwrap_or&#160;?">A quoi sert la m�thode unwrap_or&#160;?</li						</element>
						<element>
							<link href="#LII-D-7" title="A quoi sert la m�thode unwrap_or_else&#160;?">A quoi sert la m�thode unwrap_or_else&#160;?</li						</element>
						<element>
							<link href="#LII-D-8" title="A quoi sert la m�thode map&#160;?">A quoi sert la m�thode map&#160;?</li						</element>
						<element>
							<link href="#LII-D-9" title="A quoi sert la m�thode and_then&#160;?">A quoi sert la m�thode and_then&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-10" title="A quoi sert la macro try!&#160;?">A quoi sert la macro try!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-11" title="Comment utiliser la macro assert!&#160;?">Comment utiliser la macro assert!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-12" title="Comment utiliser la macro assert_eq!&#160;?">Comment utiliser la macro assert_eq!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-13" title="Comment utiliser la macro debug_assert!&#160;?">Comment utiliser la macro debug_assert!&#160;?</link>
						</element>
					</liste>
				</section>
				<section id="II-D-2">
					<title>Comment cr�er un type sp�cifique d'exceptions&#160;?</title>
					<paragraph>Il n'est pas possible de cr�er de cr�er une structure cens�e repr�senter un type d'erreur, comme nous pourrions le faire en Java&#160;; Rust ne g�re pas les potentielles de cette mani�re.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<paragraph>Comment s'effectue la gestion des erreurs avec Rust&#160;?</paragraph>
				</section>
				<section id="II-D-3">
					<title>Est-il possible de cr�er des assertions&#160;?</title>
					<paragraph>Oui, bien entendu.</paragraph>
					<paragraph>Il existe trois assertions diff�rentes en Rust (toutes encapsul�es par une macro)&#160;:</paragraph>
					<liste type="1">
						<element><link href="https://doc.rust-lang.org/std/macro.assert!.html" target="_blank" title="Ouvrir un nouvel onglet">assert</link>!;</element>
						<element><link href="https://doc.rust-lang.org/std/macro.assert_eq!.html" target="_blank" title="Ouvrir un nouvel onglet">assert_eq</link>!;</element>
						<element><link href="https://doc.rust-lang.org/std/macro.debug_assert!.html" target="_blank" title="Ouvrir un nouvel onglet">debug_assert</link>!.</element>
					</liste>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>
							<link href="#LII-D-11" title="Comment utiliser la macro assert!&#160;?">Comment utiliser la macro assert!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-12" title="Comment utiliser la macro assert_eq!&#160;?">Comment utiliser la macro assert_eq!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-13" title="Comment utiliser la macro debug_assert!&#160;?">Comment utiliser la macro debug_assert!&#160;?</link>
						</element>
					</liste>
				</section>
				<section id="II-D-4">
					<title>A quoi sert la macro panic&#160;!&#160;?</title>
					<paragraph>La macro panic! pourrait �tre compar�e aux exceptions  RuntimeException en Java qui sont, � coup s�r, des erreurs bloquantes.</paragraph>
					<code dissimulable="1" langage="java" showLines="1" startLine="1" titre="Exemple de dead code">public class MyClass 
{
        public static void main(String[] args) 
        {
            throw new RuntimeException("Error !");
            System.out.println("Dead code.");
        }
}</code>
					<paragraph>Elle est donc la macro la plus bas niveau que l'on peut retrouver parmi les macros et/ou fonctions propos�es par la biblioth�que standard; Elle ne prend rien en compte mis � part l'arr�t du programme et l'affichage de la trace de la pile.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Exemple de dead code en Rust">fn main()
{
    panic!("Error !");
    println!("Dead code");
}</code>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>A quoi sert la m�thode unwrap&#160;?</element>
						<element>A quoi sert la m�thode and_then&#160;?</element>
						<element>A quoi sert la macro try!&#160;?</element>
					</liste>
				</section>
				<section id="II-D-5">
					<title>A quoi sert la m�thode unwrap&#160;?</title>
				</section>
				<section id="II-D-6">
					<title>A quoi sert la fonction unwrap_or&#160;?</title>
				</section>
				<section id="II-D-7">
					<title>A quoi sert la fonction unwrap_or_else&#160;?</title>
				</section>
				<section id="II-D-8">
					<title>A quoi sert la fonction map&#160;?</title>
				</section>
				<section id="II-D-9">
					<title>A quoi sert la m�thode and_then&#160;?</title>
					<paragraph>La m�thode and_then() permet d'effectuer des op�rations sur la structure qui l'impl�mente, puis renvoie une nouvelle instance de cette derni�re.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation de la m�thode and_then()">fn concat(arg: &amp;str) -> Option&lt;String>
{
    Some(arg.to_string() + "world!")
}
fn main()
{
    let foo = Some("Hello ");
    println!("{}", foo.and_then(concat).unwrap());
}</code>
					<paragraph>Actuellement, les structures qui impl�mentent la m�thode and_then() sont&#160;:</paragraph>
					<liste>
						<element>Option&lt;T>;</element>
						<element>Result&lt;T, E>;</element>
					</liste>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>A quoi sert la m�thode unwrap()&#160;?</element>
						<element>Qu'est-ce que la structure Result&lt;T, E>&#160;?</element>
						<element>Qu'est-ce que la structure Option&lt;T>&#160;?</element>
					</liste>
				</section>
				<section id="II-D-10">
					<title>A quoi sert la macro try!&#160;?</title>
				</section>
				<section id="II-D-11">
					<title>Comment utiliser la macro assert!&#160;?</title>
					<paragraph>La macro assert! capture deux types �&#160;d'expressions&#160;� diff�rents&#160;:</paragraph>
					<paragraph>Les expressions � proprement parler, qui pourraient �tre illustr�es par les exemples suivants&#160;: </paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">2 * 2, if &#8230; else &#8230;, foo()&#160;;</code>
					<paragraph>Les �&#160;tokens tree&#160;� qui pourraient �tre illustr�s par n'importe quoi d'autres figurant dans la syntaxe du langage. (puisque, dans l'absolu, le compilateur repr�sente tout ce qui est r�dig� dans les fichiers sources gr�ce � une nomenclature bien � lui)</paragraph>
					<paragraph>Donc si nous r�cup�rons le code source raccourci de la documentation, cela donne ceci&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Source de la macro assert!">macro_rules! assert {
    ( $ cond : expr ) => { ... };
    (
$ cond : expr , $ ( $ arg : tt ) + ) => { ... };
}</code>
					<paragraph>Si certaines choses vous �chappent, n'h�sitez pas � vous rendre sur les liens propos�s en bas de cette Q/R.</paragraph>
					<paragraph>
						<b>A quoi sert le second param�tre&#160;?</b>
					</paragraph>
					<paragraph>Le second peut, par exemple, accueillir un message personnalis� pour la macro panic! facilitant ainsi le d�bogage.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utiliser la macro assert!">fn foo(arg: Option&lt;String>) -> ()
{
    let bar : String = String::from("Hello world!");
    let mut some : Option&lt;String> = None;
    assert!(!arg.is_none(), "Arg is None");
    assert!(arg.unwrap().eq(&amp;bar), "arg n'est pas �gal � bar");
}

fn main() -> ()
{
    foo(Some("Ok".to_string()));
    foo(None);
}</code>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element><link href="https://is.gd/wsqrbp" target="_blank" title="Ouvrir un nouvel onglet">Visionner le r�sultat de l'exemple</link> (requiert une connexion internet)</element>
						<element>Comment utiliser une macro&#160;?</element>
						<element>[macro]Antis�che des sous-types</element>
					</liste>
				</section>
				<section id="II-D-12">
					<title>Comment utiliser la macro assert_eq!&#160;?</title>
					<paragraph>&#160;<inline langage="rust">assert_eq!</inline> est un d�riv� de la macro <inline langage="rust">assert!</inline> et permet de tester directement l'�galit� de deux objets<noteBasPage>Le terme �&#160;objet&#160;� est ici utilis� pour d�signer toutes les entit�s pouvant �tre compar�es � d'autres. (cela ne concerne donc pas que les instances des structures)</noteBasPage>.</paragraph>
					<paragraph>Bien entendu, elle h�rite �galement du message personnalis� pour la macro <inline langage="rust">panic!</inline>.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utiliser la macro assert_eq!">fn foo(arg: Option&lt;String>) -> ()
{
    let bar : String = String::from("Hello world!");
    let mut some : Option&lt;String> = None;
    assert!(!arg.is_none(), "Arg is None");
    assert_eq!(arg.unwrap(), bar, "arg n'est pas �gal � bar");
}

fn main() -> ()
{
    foo(Some("Ok".to_string()));
    foo(None);
}</code>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>
							<link href="https://is.gd/en8FRZ" target="_blank" title="Ouvrir un nouvel onglet">Visionner le r�sultat de l'exemple (requiert une connexion internet)</link>
						</element>
						<element>
							<link href="#LII-A-33" title="Comment utiliser une macro&#160;?">Comment utiliser une macro&#160;?</link>
						</element>
						<element>[macro]Antis�che des sous-types</element>
					</liste>
				</section>
				<section id="II-D-13">
					<title>Comment utiliser la macro debug_assert!&#160;?</title>
					<paragraph>
						<b>O� puis-je l'utiliser&#160;?</b>
					</paragraph>
					<paragraph><inline langage="rust">debug_assert!</inline> ainsi que ses d�riv�s (<inline langage="rust">debug_assert_eq!</inline>) ne sont compil�es que lorsque le code source est compil� en mode d�bug. (mode par d�faut de <b>rustc</b>)</paragraph>
					<paragraph>Vous ne devez pas compter sur ces assertions pour contr�ler le flux de votre programme en production, assurez-vous toujours d'avoir une assertion compil�e en mode release.</paragraph>
					<rich-imgtext type="info">
						<paragraph>Si vous souhaitez toutefois les utiliser dans une binaire optimis�, vous devez passer l'argument -C debug-assertions au compilateur.</paragraph>
					</rich-imgtext>
					<paragraph>
						<b>Comment l'utiliser&#160;?</b>
					</paragraph>
					<paragraph>En dehors du contexte dans lequel ces assertions doivent �tre d�clar�es, la mani�re dont elles sont utilis�es ne changent pas.</paragraph>
					<paragraph>Voir aussi&#160;:</paragraph>
					<liste>
						<element>
							<link href="#LII-D-11" title="Comment utiliser la macro assert!&#160;?">Comment utiliser la macro assert!&#160;?</link>
						</element>
						<element>
							<link href="#LII-D-12" title="Comment utiliser la macro assert_eq!&#160;?">Comment utiliser la macro assert_eq!&#160;?</link>
						</element>
						<element>
							<link href="#LII-A-33" title="Comment utiliser une macro&#160;?">Comment utiliser une macro&#160;?</link>
						</element>
					</liste>
				</section>
				<section id="II-D-14">
					<title>Qu'est-ce que la structure Result&lt;T, E>&#160;?</title>
					<paragraph><inline langage="rust">Result&lt;T, E></inline> est une �num�ration contenant deux constructeurs&#160;:</paragraph>
					<liste type="1">
						<element><inline langage="rust">Ok(T)</inline>,</element>
						<element><inline langage="rust">Err(E)</inline>.</element>
					</liste>
					<paragraph>Elle permet de g�rer convenablement les cas o� l'entr�e <inline langage="rust">T</inline> ne correspond pas � nos attentes et ainsi le communiquer au reste du programme pour que l'incident soit rattrap� plus loin si besoin.</paragraph>
					<paragraph>Voir aussi&#160;: Comment utiliser la structure <inline langage="rust">Result&lt;T, E></inline>&#160;?</paragraph>
				</section>
				<section id="II-D-15">
					<title>Comment utiliser la structure Result&lt;T, E>&#160;?</title>
					<paragraph>L'utilisation de cette �num�ration requiert quelques notions quant � la gestion des erreurs avec Rust&#160;; Ce dernier ne permettant pas l'utilisation des exceptions, cette structure vous permettra de conserver l'entr�e si elle correspond � vos attentes, ou le message d'erreur si quelque chose ne s'est pas pass� correctement.</paragraph>
					<paragraph>Voici un exemple simple de gestion d'erreur&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Gestion d'erreur avec unwrap() seulement">fn foo&lt;'a, 'b>(arg: Option&lt;&amp;'a str>) -> Result&lt;String, &amp;'b str>
{
    if let Some(content) = arg
    {
        let unwrapping = arg.unwrap();
        return Ok(unwrapping.to_string());
    }

    return Err("L'argument ne contient rien.");
}

fn main()
{
    match foo(None)
    {
        Ok(content) => println!("Ok: {}", content),
        Err(err) => println!("Error: {}", err.to_string()),
    }
}</code>
					<rich-imgtext type="warning">
						<paragraph>Attention, cet exemple fonctionne mais il n'est pas recommand� d'op�rer de cette mani�re pour g�rer vos erreurs.</paragraph>
						<paragraph>Dans un cadre autre que p�dagogique, il est conseill� d'utiliser la macro �&#160;try!&#160;� pour envelopper les parties de notre code susceptible de lever une erreur.</paragraph>
					</rich-imgtext>
					<paragraph>Voir aussi&#160;:</paragraph>
					<paragraph>A quoi sert la macro �&#160;try!&#160;�&#160;?</paragraph>
					<paragraph>A quoi sert la macro �&#160;panic!&#160;�&#160;?</paragraph>
					<paragraph>
						<link href="https://is.gd/kof5ew" langue="Src" target="_blank" title="Ouvrir un nouvel onglet">Le r�sultat de cet exemple</link>
					</paragraph>
				</section>
			</section>
			<section id="II-E">
				<title>Meta-donn�es</title>
				<rich-imgtext type="info">
					<paragraph>WIP</paragraph>
				</rich-imgtext>
			</section>
			<section id="II-F">
				<title>I/O</title>
				<rich-imgtext type="info">
					<paragraph>WIP</paragraph>
				</rich-imgtext>
			</section>
			<section id="II-G">
				<title>Antis�ches Rust</title>
				<rich-imgtext type="info">
					<paragraph>WIP</paragraph>
				</rich-imgtext>
			</section>
			<section id="II-H">
				<title>Erreurs, difficult�s</title>
				<section id="II-H-1">
					<title>Que puis-je trouver dans cette section&#160;?</title>
					<paragraph>Vous pourrez retrouver des �&#160;trucs et astuces&#160;� pour r�soudre un probl�me plus ou moins commun et complexe.</paragraph>
					<paragraph>Ce qui signifie que si vous souhaitez ne serait-ce que conserver des notes quant aux manipulations requises pour se sortir d'un mauvais pas, d'un contexte qui pr�te � confusion, vos contributions sont les bienvenues dans cette section. :)</paragraph>
					<rich-imgtext type="info">
						<paragraph>Les contributions publi�es (au sein de cette section, comme dans la FAQ toute enti�re) sont relues, mais peuvent toujours contenir des erreurs&#160;; N'h�sitez pas � les signaler (en contactant le responsable de la FAQ ou un mainteneur, par exemple), ou � renvoyer une version corrig�e de la Q/R en question. Merci.</paragraph>
					</rich-imgtext>
				</section>
				<section id="II-H-2">
					<title>Comment r�cup�rer le vecteur d'une instance de la structure Chars&#160;?</title>
					<paragraph>Il est parfois n�cessaire d'�clater une cha�ne pour traiter ses caract�res au cas par cas&#160;; Jusqu'ici, Rust vous propose une m�thode plut�t intuitive nomm�e <inline langage="rust">chars()</inline>.</paragraph>
					<paragraph>Apr�s avoir �clat�e la cha�ne, vous souhaiteriez peut-�tre it�rer plusieurs fois sur celle-ci, sans succ�s.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1">fn main()
{
    let foo = String::from("Hello");
    let bar = foo.chars();
    
    for letter in bar {}
    for letter in bar {}    
}</code>
					<paragraph>Erreur&#160;:</paragraph>
					<code langage="text" showLines="1" startLine="1">error[E0382]: use of moved value: `bar`
 --> &lt;anon>:7:19
  |
6 |     for letter in bar {}
  |                   --- value moved here
7 |     for letter in bar {}    
  |                   ^^^ value used here after move
  |</code>
					<paragraph>La solution pourrait �tre la suivante&#160;:</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Acc�s par r�f�rence">    let foo = String::from("Hello");
    let bar = foo.chars();
    
    for letter in &amp;bar {}
    for letter in &amp;bar {}</code>
					<code dissimulable="1" langage="text" showLines="1" startLine="1">error[E0277]: the trait bound `&amp;std::str::Chars&lt;'_>: std::iter::Iterator` is not satisfied
 --> &lt;anon>:6:5
  |
6 |     for letter in &amp;bar {}
  |     ^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `&amp;std::str::Chars&lt;'_>` is not an iterator; maybe try calling `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`</code>
					<paragraph>Mais r�coltez encore une erreur&#8230;</paragraph>
					<paragraph>Le compilateur vous invite alors � essayer d'appeler la m�thode <inline langage="rust">.iter()</inline> qui est cens�e �tre impl�ment�e par toutes les structures impl�mentant l'interface <inline langage="rust">Iterator</inline>; Ce n'est malheureusement pas le cas pour la structure <inline langage="rust">Chars</inline>.</paragraph>
					<paragraph>
						<b>Que faire alors&#160;?</b>
					</paragraph>
					<paragraph>La m�thode rempla�ant <inline langage="rust">.iter()</inline> est <inline langage="rust">.collect()</inline>; Cette derni�re vous permet de r�cup�rer un vecteur contenant toutes les entit�s<noteBasPage>En l'occurrence, ici, les caract�res.</noteBasPage> de l'ancien it�rateur.</paragraph>
					<paragraph>Vous pouvez d�sormais acc�der � votre ressource par r�f�rence et ainsi la parcourir autant de fois que vous le souhaitez.</paragraph>
					<code dissimulable="1" langage="rust" showLines="1" startLine="1" titre="Utilisation de la m�thode .collect()">fn main()
{
    let foo = String::from("Hello");
    let bar = foo.chars();
    let baz : Vec&lt;char> = bar.collect();
    for letter in &amp;baz {}
    for letter in &amp;baz {}    
}</code>
				</section>
			</section>
		</section>
	</summary>
</document>
